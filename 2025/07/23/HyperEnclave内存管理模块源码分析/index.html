<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>HyperEnclave内存管理模块源码与原理分析 | 凌霄的博客</title><meta name="keywords" content="HyperEnclave,TEE,内存管理"><meta name="author" content="XR"><meta name="copyright" content="XR"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="HyperEnclave内存管理模块源码与原理分析"><meta name="application-name" content="HyperEnclave内存管理模块源码与原理分析"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="HyperEnclave内存管理模块源码与原理分析"><meta property="og:url" content="http://example.com/2025/07/23/HyperEnclave%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html"><meta property="og:site_name" content="凌霄的博客"><meta property="og:description" content="深入剖析HyperEnclave内存管理模块的分层架构设计与源码实现。涵盖物理内存管理、多级页表机制、虚拟地址转换、可转换内存模型等核心技术，全面揭示其安全内存管理的底层原理。"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/20250722115459961.png"><meta property="article:author" content="XR"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/20250722115459961.png"><meta name="description" content="深入剖析HyperEnclave内存管理模块的分层架构设计与源码实现。涵盖物理内存管理、多级页表机制、虚拟地址转换、可转换内存模型等核心技术，全面揭示其安全内存管理的底层原理。"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2025/07/23/HyperEnclave%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🧱 团队小组发动机"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: XR","link":"链接: ","source":"来源: 凌霄的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '凌霄的博客',
  title: 'HyperEnclave内存管理模块源码与原理分析',
  postAI: '',
  pageFillDescription: 'HyperEnclave内存管理模块源码与原理分析, 目录, 1. 概述, 设计哲学, 模块结构, 2. 第一层：物理内存管理 (frame.rs), 核心数据结构, 分配与释放, 底层原理, 3. 第二层：虚拟地址与权限 (addr.rs mod.rs), 地址空间定义, 地址转换与加密, 场景一：Hypervisor自身内存的线性地址转换, 场景二：Guest虚拟机的通用地址转换, 物理地址的硬件加密标记, 内存权限标志, 4. 第三层：页表核心机制 (paging.rs), 核心抽象：GenericPTE, 数据结构：Level4PageTable, 地址转换机制详解, 虚拟地址索引提取, 页表遍历核心逻辑, 地址查询接口, 地址转换完整流程, 底层原理：MMU与CR3, 总结, 5. 第四层：高级内存映射 (mm.rs mapper.rs), 核心数据结构, 核心逻辑：MemorySetinsert, 底层原理：从API到硬件, 6. 第五层：Enclave可转换内存管理 (cmr.rs), 设计思想：可转换内存, 核心数据结构, 核心逻辑：initialize_cmrm, 底层原理：安全内存的实现, 7.内存访问流程和地址转换架构, 7.1 Guest程序的内存访问机制, 地址转换流程, 普通Guest内存访问（NonSecure）, 页表遍历机制, 7.2. Enclave程序的内存访问机制, 特殊的地址转换, Enclave页面加载机制, 7.3. 控制层次分析, 7.3.1 Guest操作系统控制范围, 7.3.2 HyperEnclave控制范围, 1）Nested页表管理, 2）Enclave专用管理, 3）内存安全验证, 7.4 内存访问的完整流程图, Guest程序内存访问, Enclave程序内存访问, 关键差异总结, 8. 总结内存管理模块源码与原理分析目录概述设计哲学模块结构第一层物理内存管理核心数据结构分配与释放底层原理第二层虚拟地址与权限地址空间定义地址转换与加密内存权限标志第三层页表核心机制核心抽象数据结构地址转换机制详解底层原理与第四层高级内存映射核心数据结构核心逻辑底层原理从到硬件第五层可转换内存管理设计思想可转换内存核心数据结构核心逻辑底层原理安全内存的实现内存访问流程和地址转换架构程序的内存访问机制程序的内存访问机制控制层次分析内存访问的完整流程图总结概述项目源码紧接上一篇启动和初始化流程我们继续一起学习这次我们主要看的是的内存管理的设计与实现这个可能是中最关键的部分了设计哲学的内存管理模块是其安全性的基石它的设计哲学是分层抽象和安全隔离通过将物理内存管理页表机制和高级内存映射分离开来实现了清晰可维护且安全的代码结构那最终目标就是为每个提供一个完全独立受硬件保护的加密地址空间模块结构我们看包就可以发现模块文件及其职责的组织体现了分层思想底层物理物理内存页帧的分配与回收核心虚拟化基础地址类型的定义与转换虚拟内存的核心实现多级页表高层抽象将页表和物理帧组合成易于使用的内存映射专用功能安全页缓存的特殊管理自身的堆内存安全的内存访问接口第一层物理内存管理这是最底层负责管理拥有的所有物理内存核心数据结构全局唯一的物理帧分配器使用库一个位图分配器来跟踪哪些物理页帧是空闲的代表一个或多个连续的已分配的物理页帧它是一个所有权句柄当对象被时其占用的物理内存会自动释放分配与释放在位图中找到一个空闲位将其标记为已使用并计算出对应的物理地址返回则执行相反操作底层原理这一层不涉及虚拟地址或特性它仅仅是对一块物理内存进行软件层面的簿记你可以把它想象成一个简化的但操作对象是固定大小的物理内存页帧第二层虚拟地址与权限这一层定义了内存操作的基础单位和规则地址空间定义通过类型别名区分了不同上下文中的地址增强了代码的可读性和安全性挺有意思的地址转换与加密中存在两种不同的地址转换机制以及一种地址加密标记机制场景一自身内存的线性地址转换对于自身代码和数据的内存它采用的是一种简单的线性映射实现原理这是一个在启动时计算好的固定偏移量代表了的虚拟地址基址和它在物理内存中的加载地址之间的差值转换过程函数用虚拟地址减去这个固定的偏移量从而得到物理地址则执行相反操作并且过滤掉的使用场景这种方法仅用于自身的地址空间因为它简单高效并且的内存布局在启动后是固定的场景二虚拟机的通用地址转换对于的虚拟地址空间包括情况要复杂得多因为它需要支持任意的非线性的映射这依赖于多级页表机制关键接口遍历页表获取有效的映射信息返回物理地址内存标志页面大小这种地址转换通过多级页表遍历实现详细机制将在第三层页表核心机制中详细介绍物理地址的硬件加密标记除了地址转换还提供了地址加密标记功能注意这不是地址转换而是地址加密标记函数的作用是为一个物理地址启用硬件内存加密它通过在物理地址上设置一个特殊的标志位告诉的内存控制器对该地址的访问进行加解密操作这是处理器提供的一项硬件安全功能当启用后的内存控制器会在数据离开芯片写入内存时自动加密在数据从内存读入时自动解密在物理地址总线上增加了一个额外的位称为如果一个物理地址的被设置为内存控制器就会对该地址的访问执行加解密操作内存权限标志底层原理中的每一位都直接对应页表项中的一个控制位例如对应位对应位逻辑相反对应位当创建页表项时这些标志位会被组合并写入的硬件结构中由的强制执行第三层页表核心机制这是内存虚拟化的核心实现了将虚拟地址翻译成物理地址的机制核心抽象这个是页表实现的精髓它定义了一个页表项必须具备的通用行为将上层逻辑与具体硬件如或的格式解耦数据结构使用一个级页表结构来管理地址空间这与架构相匹配地址转换机制详解的地址转换是通过多级页表遍历实现的这是现代操作系统内存管理的核心虚拟地址索引提取首先系统需要从位虚拟地址中提取各级页表的索引提取位提取位提取位提取位地址分解原理的位虚拟地址被分为个部分符号扩展位必须与第位相同页表索引位个条目页表索引位个条目页表索引位个条目页表索引位个条目页内偏移位页面页表遍历核心逻辑从页表根开始相当于从寄存器获取地址进入页表可能是大页进入页表可能是大页进入页表最终级别页面地址查询接口遍历页表获取有效的映射信息返回物理地址内存标志页面大小函数的实现获取页表项和级别检查页表项是否被使用获取页面大小检查页表项是否有效位计算最终物理地址页面基址页内偏移地址转换完整流程起始点从根页表开始根地址存储在中遍历使用虚拟地址的位作为索引在页表中找到遍历如果不是叶子节点使用位在页表中查找遍历如果不是叶子节点使用位在页表中查找遍历如果不是叶子节点使用位在页表中查找最终地址的基址虚拟地址的低位页内偏移最终物理地址底层原理与函数是在软件中模拟了硬件内存管理单元的工作流程在真实运行时通过方法将根页表的物理地址加载到寄存器中伪代码实际由库提供之后每一次内存访问的都会自动硬件级地执行上述函数中的页表遍历过程以极高的速度完成地址翻译如果翻译失败例如的位为会触发一个异常将控制权交还给的处理程序总结的核心作用地址映射记录虚拟地址到物理地址的映射关系权限控制记录内存页面的访问权限读写执行用户加密等状态管理记录页面状态是否存在是否被访问是否为大页等硬件接口作为软件与硬件之间的数据结构这块如果你之前不是很了解的或者不太清楚的宏观地址转换架构这个文章后面会说直接说细节可能很难理解透第四层高级内存映射这一层提供了面向开发者的更易于使用的将物理帧分配和页表操作封装在一起核心数据结构内含一个页表代表一个完整的地址空间如一个的地址空间它包含一个页表和多个定义了一个连续的虚拟内存区域及其属性核心逻辑检查虚拟地址区域是否与其他区域重叠调用页表层的函数将区域信息存入是关键它内部会遍历中的每一个虚拟页面为每个虚拟页面调用分配一个物理帧计算出应该在页表中的位置创建一个将虚拟页面链接到分配的物理帧并设置好中指定的权限底层原理从到硬件一个调用最终会转化为一系列底层的操作软件簿记更新的位图内存写操作修改多级页表中的内容刷新执行指令使快表中的旧缓存失效确保使用最新的页表映射第五层可转换内存管理这是最具特色的部分专门用于管理的安全内存设计思想可转换内存不静态划分普通内存和安全内存而是提出可转换内存的概念这意味着一块物理内存页可以在运行时被动态地转换为普通内存安全内存或内部内存核心数据结构页面为系统中每一页可转换的物理内存维护一个元数据这个巨大的元数据数组就是的核心是它记录了对应物理页的当前类型核心逻辑根据物理地址所在的预定义范围判断其初始状态此函数在启动时被调用它遍历所有可转换内存根据固件提供的信息如哪些内存预留为初始为每个物理页设置其初始底层原理安全内存的实现将一页普通内存转换为安全内存的完整流程是软件层调用的接口将对应的从更新为页表层找到映射到该物理页的并将其添加标志地址转换层在构建最终时函数会为该物理地址设置硬件层当使用这个进行地址翻译时它将带有的物理地址发送到内存控制器内存控制器识别到后自动使用引擎对该次内存访问进行加解密内存访问流程和地址转换架构程序内存访问应用程序虚拟地址页表遍历物理地址页表实际物理内存程序内存访问应用程序虚拟地址页表遍历物理地址页表实际物理内存控制层次操作系统管理页表管理页表管理页表安全策略控制程序的内存访问机制地址转换流程从代码分析可以看出程序的内存访问分为两种情况普通内存访问转换步骤虚拟地址页表查询物理地址物理地址页表实际物理内存页表遍历机制页表遍历通过四级页表结构实现位位位位程序的内存访问机制特殊的地址转换程序的内存访问更复杂需要额外的安全检查页面加载机制页面未映射触发页面错误页面被回收需要重新加载页面正常直接返回转换步骤虚拟地址页表查询物理地址物理地址页表实际物理内存额外安全检查验证权限检查状态验证控制层次分析操作系统控制范围操作系统控制的内容从代码推断的控制范围管理自己的页表但受到的监控控制页表管理创建修改删除虚拟地址到物理地址的映射内存分配在物理地址空间内分配内存给应用程序权限管理设置页面的读写执行权限受限进程隔离在内部实现进程间的内存隔离无法控制页表的内存管理实际物理内存的分配跨的安全策略控制范围从代码可以看出的全面控制控制页表管理二级地址转换物理地址实际物理地址内存隔离确保不同无法访问对方内存访问权限控制对物理内存的访问权限专用管理页表专门为创建的页表管理页面缓存映射管理安全策略实施的安全隔离策略内存安全验证地址验证验证访问的物理地址是否合法安全边界强制执行安全内存和非安全内存的边界访问控制根据上下文控制内存访问权限内存访问的完整流程图程序内存访问应用硬件访问虚拟地址查询页表返回物理地址查询页表返回实际物理地址完成内存访问程序内存访问应用管理器硬件访问虚拟地址查询页表验证页面状态和权限返回验证结果返回物理地址查询页表返回实际物理地址完成内存访问关键差异总结特性程序程序页表管理管理管理安全检查基本权限检查权限状态验证内存区域普通物理内存加密页面缓存隔离级别进程级隔离硬件级加密隔离故障处理标准页面错误特殊安全异常动态管理内存管理这种设计确保了程序具有比普通程序更强的安全保障同时通过控制关键的页表结构和安全策略实现了对整个系统内存访问的全面管控总结的内存管理是一个设计精良层次分明的系统它从最底层的物理帧位图开始通过多级页表和抽象构建了强大的虚拟内存机制利用将其封装成易用的高级最后通过创新的可转换内存模型实现了对安全内存的灵活动态管理整个系统的实现深度依赖于对硬件特性如加密位的直接利用并通过的类型系统和抽象能力将这些复杂的底层操作安全清晰地组织起来',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-07-23 14:56:55',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">凌霄的博客</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/kongxiaoran/image-repo/blog20241226231130275.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://cdn.jsdelivr.net/gh/kongxiaoran/image-repo/blog20241226231130275.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/kongxiaoran/image-repo/blog20241226231143327.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://cdn.jsdelivr.net/gh/kongxiaoran/image-repo/blog20241226231143327.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Argon2/" style="font-size: 1.05rem;">Argon2<sup>1</sup></a><a href="/tags/DNS/" style="font-size: 1.05rem;">DNS<sup>4</sup></a><a href="/tags/HBase/" style="font-size: 1.05rem;">HBase<sup>1</sup></a><a href="/tags/HDFS/" style="font-size: 1.05rem;">HDFS<sup>4</sup></a><a href="/tags/HTTP/" style="font-size: 1.05rem;">HTTP<sup>1</sup></a><a href="/tags/Hadoop/" style="font-size: 1.05rem;">Hadoop<sup>4</sup></a><a href="/tags/Hive/" style="font-size: 1.05rem;">Hive<sup>1</sup></a><a href="/tags/HyperEnclave/" style="font-size: 1.05rem;">HyperEnclave<sup>5</sup></a><a href="/tags/Java/" style="font-size: 1.05rem;">Java<sup>8</sup></a><a href="/tags/Kubernetes/" style="font-size: 1.05rem;">Kubernetes<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>7</sup></a><a href="/tags/Maven/" style="font-size: 1.05rem;">Maven<sup>1</sup></a><a href="/tags/NAT/" style="font-size: 1.05rem;">NAT<sup>1</sup></a><a href="/tags/RDD/" style="font-size: 1.05rem;">RDD<sup>2</sup></a><a href="/tags/SGX/" style="font-size: 1.05rem;">SGX<sup>2</sup></a><a href="/tags/Spark/" style="font-size: 1.05rem;">Spark<sup>11</sup></a><a href="/tags/Spring/" style="font-size: 1.05rem;">Spring<sup>3</sup></a><a href="/tags/TDX/" style="font-size: 1.05rem;">TDX<sup>2</sup></a><a href="/tags/TEE/" style="font-size: 1.05rem;">TEE<sup>9</sup></a><a href="/tags/TME/" style="font-size: 1.05rem;">TME<sup>2</sup></a><a href="/tags/YARN/" style="font-size: 1.05rem;">YARN<sup>1</sup></a><a href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" style="font-size: 1.05rem;">云原生<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 1.05rem;">代理<sup>1</sup></a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/" style="font-size: 1.05rem;">分布式存储<sup>2</sup></a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/" style="font-size: 1.05rem;">分布式计算<sup>3</sup></a><a href="/tags/%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E9%99%90%E5%88%B6/" style="font-size: 1.05rem;">地理位置限制<sup>1</sup></a><a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 1.05rem;">大数据<sup>7</sup></a><a href="/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/" style="font-size: 1.05rem;">学习路线<sup>1</sup></a><a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 1.05rem;">安全<sup>2</sup></a><a href="/tags/%E5%AF%86%E7%A0%81%E5%93%88%E5%B8%8C/" style="font-size: 1.05rem;">密码哈希<sup>1</sup></a><a href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" style="font-size: 1.05rem;">密码学<sup>5</sup></a><a href="/tags/%E6%8A%80%E6%9C%AF%E4%B8%93%E6%A0%8F/" style="font-size: 1.05rem;">技术专栏<sup>1</sup></a><a href="/tags/%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97/" style="font-size: 1.05rem;">机密计算<sup>2</sup></a><a href="/tags/%E6%B5%81%E5%AA%92%E4%BD%93%E8%A7%A3%E9%94%81/" style="font-size: 1.05rem;">流媒体解锁<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">网络<sup>4</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90/" style="font-size: 1.05rem;">网络分析<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" style="font-size: 1.05rem;">网络安全<sup>1</sup></a><a href="/tags/%E9%98%B2%E7%81%AB%E5%A2%99/" style="font-size: 1.05rem;">防火墙<sup>2</sup></a><a href="/tags/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/" style="font-size: 1.05rem;">隐私计算<sup>4</sup></a><a href="/tags/%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84/" style="font-size: 1.05rem;">集群架构<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/09/"><span class="card-archive-list-date">九月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/08/"><span class="card-archive-list-date">八月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">七月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">17</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/06/"><span class="card-archive-list-date">六月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">32</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/" itemprop="url">隐私计算</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/HyperEnclave/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>HyperEnclave</span></a><a class="article-meta__tags" href="/tags/TEE/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>TEE</span></a><a class="article-meta__tags" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>内存管理</span></a></span></div></div><h1 class="post-title" itemprop="name headline">HyperEnclave内存管理模块源码与原理分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-07-23T11:00:00.000Z" title="发表于 2025-07-23 19:00:00">2025-07-23</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-07-23T06:56:55.814Z" title="更新于 2025-07-23 14:56:55">2025-07-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="HyperEnclave内存管理模块源码与原理分析"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为杭州"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>杭州</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/20250722115459961.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2025/07/23/HyperEnclave%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><header><a class="post-meta-categories" href="/categories/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/" itemprop="url">隐私计算</a><a href="/tags/HyperEnclave/" tabindex="-1" itemprop="url">HyperEnclave</a><a href="/tags/TEE/" tabindex="-1" itemprop="url">TEE</a><a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" tabindex="-1" itemprop="url">内存管理</a><h1 id="CrawlerTitle" itemprop="name headline">HyperEnclave内存管理模块源码与原理分析</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">XR</span><time itemprop="dateCreated datePublished" datetime="2025-07-23T11:00:00.000Z" title="发表于 2025-07-23 19:00:00">2025-07-23</time><time itemprop="dateCreated datePublished" datetime="2025-07-23T06:56:55.814Z" title="更新于 2025-07-23 14:56:55">2025-07-23</time></header><h1 id="HyperEnclave内存管理模块源码与原理分析"><a href="#HyperEnclave内存管理模块源码与原理分析" class="headerlink" title="HyperEnclave内存管理模块源码与原理分析"></a>HyperEnclave内存管理模块源码与原理分析</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li><a href="#1-%E6%A6%82%E8%BF%B0"><strong>概述</strong></a><ul>
<li><a href="#%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6">设计哲学</a></li>
<li><a href="#%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84">模块结构</a></li>
</ul>
</li>
<li><a href="#2-%E7%AC%AC%E4%B8%80%E5%B1%82%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-framers"><strong>第一层：物理内存管理 (<code>frame.rs</code>)</strong></a><ul>
<li><a href="#%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">核心数据结构</a></li>
<li><a href="#%E5%88%86%E9%85%8D%E4%B8%8E%E9%87%8A%E6%94%BE">分配与释放</a></li>
<li><a href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86">底层原理</a></li>
</ul>
</li>
<li><a href="#3-%E7%AC%AC%E4%BA%8C%E5%B1%82%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E4%B8%8E%E6%9D%83%E9%99%90-addrs-modrs"><strong>第二层：虚拟地址与权限 (<code>addr.rs</code>, <code>mod.rs</code>)</strong></a><ul>
<li><a href="#%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%AE%9A%E4%B9%89">地址空间定义</a></li>
<li><a href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%8A%A0%E5%AF%86">地址转换与加密</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E6%9D%83%E9%99%90%E6%A0%87%E5%BF%97">内存权限标志</a></li>
</ul>
</li>
<li><a href="#4-%E7%AC%AC%E4%B8%89%E5%B1%82%E9%A1%B5%E8%A1%A8%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6-pagingrs"><strong>第三层：页表核心机制 (<code>paging.rs</code>)</strong></a><ul>
<li><a href="#%E6%A0%B8%E5%BF%83%E6%8A%BD%E8%B1%A1genericpte">核心抽象：<code>GenericPTE</code></a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84level4pagetable">数据结构：<code>Level4PageTable</code></a></li>
<li><a href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3">地址转换机制详解</a></li>
<li><a href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86mmu%E4%B8%8Ecr3">底层原理：MMU与CR3</a></li>
</ul>
</li>
<li><a href="#5-%E7%AC%AC%E5%9B%9B%E5%B1%82%E9%AB%98%E7%BA%A7%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84-mmrs-mapperrs"><strong>第四层：高级内存映射 (<code>mm.rs</code>, <code>mapper.rs</code>)</strong></a><ul>
<li><a href="#%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1">核心数据结构</a></li>
<li><a href="#%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91memorysetinsert">核心逻辑：<code>MemorySet::insert</code></a></li>
<li><a href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%BB%8Eapi%E5%88%B0%E7%A1%AC%E4%BB%B6">底层原理：从API到硬件</a></li>
</ul>
</li>
<li><a href="#6-%E7%AC%AC%E4%BA%94%E5%B1%82enclave%E5%8F%AF%E8%BD%AC%E6%8D%A2%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-cmrrs"><strong>第五层：Enclave可转换内存管理 (<code>cmr.rs</code>)</strong></a><ul>
<li><a href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E5%8F%AF%E8%BD%AC%E6%8D%A2%E5%86%85%E5%AD%98">设计思想：可转换内存</a></li>
<li><a href="#%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2">核心数据结构</a></li>
<li><a href="#%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91initialize_cmrm">核心逻辑：<code>initialize_cmrm</code></a></li>
<li><a href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%AE%89%E5%85%A8%E5%86%85%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0">底层原理：安全内存的实现</a></li>
</ul>
</li>
<li><a href="#7-%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B%E5%92%8C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E6%9E%B6%E6%9E%84"><strong>内存访问流程和地址转换架构</strong></a><ul>
<li><a href="#71-guest%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E6%9C%BA%E5%88%B6">Guest程序的内存访问机制</a></li>
<li><a href="#72-enclave%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E6%9C%BA%E5%88%B6">Enclave程序的内存访问机制</a></li>
<li><a href="#73-%E6%8E%A7%E5%88%B6%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90">控制层次分析</a></li>
<li><a href="#74-%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E7%9A%84%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B%E5%9B%BE">内存访问的完整流程图</a></li>
</ul>
</li>
<li><a href="#8-%E6%80%BB%E7%BB%93"><strong>总结</strong></a></li>
</ol>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><blockquote>
<p>项目源码：<a target="_blank" rel="noopener" href="https://github.com/asterinas/hyperenclave">https://github.com/asterinas/hyperenclave</a><br>紧接上一篇<a target="_blank" rel="noopener" href="https://kongxiaoran.github.io/2025/07/21/HyperEnclave%E5%90%AF%E5%8A%A8%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/">《HyperEnclave启动和初始化流程》</a>，我们继续一起学习HyperEnclave。这次我们主要看的是HyperEnclave的内存管理的设计与实现。这个可能是HyperEnclave中最关键的部分了。</p>
</blockquote>
<h3 id="设计哲学"><a href="#设计哲学" class="headerlink" title="设计哲学"></a>设计哲学</h3><p>HyperEnclave的内存管理模块是其安全性的基石。它的设计哲学是<strong>分层抽象</strong>和<strong>安全隔离</strong>。通过将物理内存管理、页表机制和高级内存映射分离开来，实现了清晰、可维护且安全的代码结构。</p>
<p>那最终目标就是为每个Enclave提供一个完全独立、受硬件保护的加密地址空间。</p>
<h3 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h3><p>我们看src&#x2F;memory包，就可以发现模块文件及其职责的组织体现了分层思想：</p>
<ul>
<li><strong>底层物理</strong><ul>
<li><code>frame.rs</code>: 物理内存页帧的分配与回收。</li>
</ul>
</li>
<li><strong>核心虚拟化</strong><ul>
<li><code>addr.rs</code>: 基础地址类型的定义与转换。</li>
<li><code>paging.rs</code>: 虚拟内存的核心，实现多级页表。</li>
</ul>
</li>
<li><strong>高层抽象</strong><ul>
<li><code>mm.rs</code> &amp; <code>mapper.rs</code>: 将页表和物理帧组合成易于使用的内存映射API。</li>
</ul>
</li>
<li><strong>专用功能</strong><ul>
<li><code>cmr.rs</code>: Enclave安全页缓存（EPC）的特殊管理。</li>
<li><code>heap.rs</code>: Hypervisor自身的堆内存。</li>
<li><code>gaccess.rs</code>: 安全的Guest内存访问接口。</li>
</ul>
</li>
</ul>
<h2 id="2-第一层：物理内存管理-frame-rs"><a href="#2-第一层：物理内存管理-frame-rs" class="headerlink" title="2. 第一层：物理内存管理 (frame.rs)"></a>2. 第一层：物理内存管理 (<code>frame.rs</code>)</h2><p>这是最底层，负责管理Hypervisor拥有的所有物理内存。</p>
<h3 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/memory/frame.rs:35-45</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FrameAllocator</span> &#123;</span><br><span class="line">    base: PhysAddr,</span><br><span class="line">    inner: FrameAlloc, <span class="comment">// BitAlloc1M</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Frame</span> &#123;</span><br><span class="line">    start_paddr: PhysAddr,</span><br><span class="line">    frame_count: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>FrameAllocator</code>: 全局唯一的物理帧分配器，使用<code>bitmap_allocator</code>库（一个位图分配器）来跟踪哪些4K物理页帧是空闲的。</li>
<li><code>Frame</code>: 代表一个或多个连续的、已分配的物理页帧。它是一个所有权句柄，当<code>Frame</code>对象被<code>drop</code>时，其占用的物理内存会自动释放。</li>
</ul>
<h3 id="分配与释放"><a href="#分配与释放" class="headerlink" title="分配与释放"></a>分配与释放</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/memory/frame.rs:60-85</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FrameAllocator</span> &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">alloc</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;PhysAddr&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ret</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">alloc</span>().<span class="title function_ invoke__">map</span>(|idx| idx * PAGE_SIZE + <span class="keyword">self</span>.base);</span><br><span class="line">        trace!(<span class="string">&quot;Allocate frame: &#123;:x?&#125;&quot;</span>, ret);</span><br><span class="line">        ret</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">dealloc</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, target: PhysAddr) &#123;</span><br><span class="line">        trace!(<span class="string">&quot;Deallocate frame: &#123;:x&#125;&quot;</span>, target);</span><br><span class="line">        <span class="keyword">self</span>.inner.<span class="title function_ invoke__">dealloc</span>((target - <span class="keyword">self</span>.base) / PAGE_SIZE)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>alloc</code>在位图中找到一个空闲位，将其标记为已使用，并计算出对应的物理地址返回。<code>dealloc</code>则执行相反操作。</p>
<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p>这一层不涉及虚拟地址或CPU特性，它仅仅是对一块物理内存进行软件层面的簿记(bookkeeping)。你可以把它想象成一个简化的<code>malloc</code>&#x2F;<code>free</code>，但操作对象是固定大小（4KB）的物理内存页帧。</p>
<h2 id="3-第二层：虚拟地址与权限-addr-rs-mod-rs"><a href="#3-第二层：虚拟地址与权限-addr-rs-mod-rs" class="headerlink" title="3. 第二层：虚拟地址与权限 (addr.rs, mod.rs)"></a>3. 第二层：虚拟地址与权限 (<code>addr.rs</code>, <code>mod.rs</code>)</h2><p>这一层定义了内存操作的基础单位和规则。</p>
<h3 id="地址空间定义"><a href="#地址空间定义" class="headerlink" title="地址空间定义"></a>地址空间定义</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/memory/addr.rs:18-25</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">VirtAddr</span> = <span class="type">usize</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">PhysAddr</span> = <span class="type">usize</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">GuestVirtAddr</span> = <span class="type">usize</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">GuestPhysAddr</span> = <span class="type">usize</span>;</span><br></pre></td></tr></table></figure>
<p>通过类型别名区分了不同上下文中的地址，增强了代码的可读性和安全性（挺有意思的）</p>
<h3 id="地址转换与加密"><a href="#地址转换与加密" class="headerlink" title="地址转换与加密"></a>地址转换与加密</h3><p>HyperEnclave中存在两种不同的地址转换机制，以及一种地址加密标记机制：</p>
<h4 id="场景一：Hypervisor自身内存的线性地址转换"><a href="#场景一：Hypervisor自身内存的线性地址转换" class="headerlink" title="场景一：Hypervisor自身内存的线性地址转换"></a><strong>场景一：Hypervisor自身内存的线性地址转换</strong></h4><p>对于Hypervisor自身代码和数据的内存，它采用的是一种简单的<strong>线性映射</strong>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/memory/addr.rs:27-32</span></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> PHYS_VIRT_OFFSET: <span class="type">usize</span> = HV_BASE</span><br><span class="line">        - crate::config::HvSystemConfig::<span class="title function_ invoke__">get</span>()</span><br><span class="line">            .hypervisor_memory</span><br><span class="line">            .phys_start <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/memory/addr.rs:41-43</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">virt_to_phys</span>(vaddr: VirtAddr) <span class="punctuation">-&gt;</span> PhysAddr &#123;</span><br><span class="line">    vaddr - *PHYS_VIRT_OFFSET</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/memory/addr.rs:45-47</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">phys_to_virt</span>(paddr: PhysAddr) <span class="punctuation">-&gt;</span> VirtAddr &#123;</span><br><span class="line">    (paddr &amp; (SME_C_BIT_OFFSET.<span class="title function_ invoke__">wrapping_sub</span>(<span class="number">1</span>))) + *PHYS_VIRT_OFFSET</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现原理：</strong></p>
<ol>
<li><code>PHYS_VIRT_OFFSET</code>: 这是一个在Hypervisor启动时计算好的<strong>固定偏移量</strong>，代表了Hypervisor的虚拟地址基址 (<code>HV_BASE</code>) 和它在物理内存中的加载地址之间的差值。</li>
<li><strong>转换过程</strong>: <code>virt_to_phys</code>函数用虚拟地址减去这个固定的偏移量，从而得到物理地址；<code>phys_to_virt</code>则执行相反操作，并且过滤掉SME的C-bit。</li>
</ol>
<p><strong>使用场景</strong>: 这种方法<strong>仅用于Hypervisor自身的地址空间</strong>，因为它简单、高效，并且Hypervisor的内存布局在启动后是固定的。</p>
<h4 id="场景二：Guest虚拟机的通用地址转换"><a href="#场景二：Guest虚拟机的通用地址转换" class="headerlink" title="场景二：Guest虚拟机的通用地址转换"></a><strong>场景二：Guest虚拟机的通用地址转换</strong></h4><p>对于Guest的虚拟地址空间（包括Enclave），情况要复杂得多，因为它需要支持任意的、非线性的映射。这依赖于<strong>多级页表</strong>机制。</p>
<p><strong>关键接口：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/memory/paging.rs:217-230</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">GenericPageTableImmut</span>: <span class="built_in">Sized</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">VA</span>: <span class="built_in">From</span>&lt;<span class="type">usize</span>&gt; + <span class="built_in">Into</span>&lt;<span class="type">usize</span>&gt; + <span class="built_in">Copy</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 遍历页表获取有效的映射信息</span></span><br><span class="line">    <span class="comment">/// 返回：(物理地址, 内存标志, 页面大小)</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">query</span>(&amp;<span class="keyword">self</span>, vaddr: <span class="keyword">Self</span>::VA) <span class="punctuation">-&gt;</span> PagingResult&lt;(PhysAddr, MemFlags, PageSize)&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种地址转换通过<strong>多级页表遍历</strong>实现，详细机制将在第三层（页表核心机制）中详细介绍。</p>
<h4 id="物理地址的硬件加密标记"><a href="#物理地址的硬件加密标记" class="headerlink" title="物理地址的硬件加密标记"></a><strong>物理地址的硬件加密标记</strong></h4><p>除了地址转换，HyperEnclave还提供了地址加密标记功能：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/memory/addr.rs:35-37</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">phys_encrypted</span>(paddr: PhysAddr) <span class="punctuation">-&gt;</span> PhysAddr &#123;</span><br><span class="line">    paddr | SME_C_BIT_OFFSET</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: 这<strong>不是地址转换</strong>，而是<strong>地址加密标记</strong>。<code>phys_encrypted</code> 函数的作用是为一个物理地址启用硬件内存加密。它通过在物理地址上设置一个特殊的标志位（C-bit），告诉CPU的内存控制器对该地址的访问进行加解密操作。</p>
<ul>
<li><p><strong>AMD SME (Secure Memory Encryption)</strong>: 这是AMD处理器提供的一项硬件安全功能。当启用SME后，CPU的内存控制器会在数据离开CPU芯片写入内存时自动加密，在数据从内存读入CPU时自动解密。</p>
</li>
<li><p><strong>C-bit (Encryption Bit)</strong>: AMD在物理地址总线上增加了一个额外的位，称为C-bit（Crypto-bit）。如果一个物理地址的C-bit被设置为1，内存控制器就会对该地址的访问执行加解密操作。</p>
</li>
</ul>
<h3 id="内存权限标志"><a href="#内存权限标志" class="headerlink" title="内存权限标志"></a>内存权限标志</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/memory/mod.rs:45-60</span></span><br><span class="line"><span class="built_in">bitflags!</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MemFlags</span>: <span class="type">u64</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> READ          = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> WRITE         = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> EXECUTE       = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">const</span> ENCRYPTED     = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>底层原理</strong>: <code>MemFlags</code>中的每一位都直接对应x86-64页表项（PTE）中的一个控制位。例如：<ul>
<li><code>READ</code> | <code>WRITE</code> 对应 <code>R/W</code> (Read&#x2F;Write) 位。</li>
<li><code>EXECUTE</code> 对应 <code>XD</code> (Execute Disable) 位（逻辑相反）。</li>
<li><code>USER</code> 对应 <code>U/S</code> (User&#x2F;Supervisor) 位。<br>当创建页表项时，这些标志位会被组合并写入PTE的硬件结构中，由CPU的MMU强制执行。</li>
</ul>
</li>
</ul>
<h2 id="4-第三层：页表核心机制-paging-rs"><a href="#4-第三层：页表核心机制-paging-rs" class="headerlink" title="4. 第三层：页表核心机制 (paging.rs)"></a>4. 第三层：页表核心机制 (<code>paging.rs</code>)</h2><p>这是内存虚拟化的核心，实现了将虚拟地址翻译成物理地址的机制。</p>
<h3 id="核心抽象：GenericPTE"><a href="#核心抽象：GenericPTE" class="headerlink" title="核心抽象：GenericPTE"></a>核心抽象：<code>GenericPTE</code></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/memory/paging.rs:166-203</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">GenericPTE</span>: <span class="built_in">Debug</span> + <span class="built_in">Clone</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">addr</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> PhysAddr;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">flags</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> MemFlags;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">is_present</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_addr</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, paddr: PhysAddr);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_flags</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, flags: MemFlags, is_huge: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> PagingResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个trait是HyperEnclave页表实现的精髓。它定义了一个页表项（PTE）必须具备的通用行为，将上层逻辑与具体硬件（如Intel EPT或AMD NPT）的PTE格式解耦。</p>
<h3 id="数据结构：Level4PageTable"><a href="#数据结构：Level4PageTable" class="headerlink" title="数据结构：Level4PageTable"></a>数据结构：<code>Level4PageTable</code></h3><p>HyperEnclave使用一个4级页表结构来管理地址空间，这与x86-64架构相匹配。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/memory/paging.rs:691-696</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Level4PageTable</span>&lt;VA, PTE: GenericPTE, I: PagingInstr&gt; &#123;</span><br><span class="line">    inner: Level4PageTableUnlocked&lt;VA, PTE, I&gt;,</span><br><span class="line">    clonee_lock: Arc&lt;Mutex&lt;()&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="地址转换机制详解"><a href="#地址转换机制详解" class="headerlink" title="地址转换机制详解"></a>地址转换机制详解</h3><p>HyperEnclave的地址转换是通过多级页表遍历实现的，这是<strong>现代操作系统内存管理的核心</strong>。</p>
<h4 id="虚拟地址索引提取"><a href="#虚拟地址索引提取" class="headerlink" title="虚拟地址索引提取"></a><strong>虚拟地址索引提取</strong></h4><p>首先，系统需要从64位虚拟地址中提取各级页表的索引：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/memory/paging.rs:865-880</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">fn</span> <span class="title function_">p4_index</span>(vaddr: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    (vaddr &gt;&gt; (<span class="number">12</span> + <span class="number">27</span>)) &amp; (ENTRY_COUNT - <span class="number">1</span>)  <span class="comment">// 提取 [47:39] 位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">fn</span> <span class="title function_">p3_index</span>(vaddr: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    (vaddr &gt;&gt; (<span class="number">12</span> + <span class="number">18</span>)) &amp; (ENTRY_COUNT - <span class="number">1</span>)  <span class="comment">// 提取 [38:30] 位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">fn</span> <span class="title function_">p2_index</span>(vaddr: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    (vaddr &gt;&gt; (<span class="number">12</span> + <span class="number">9</span>)) &amp; (ENTRY_COUNT - <span class="number">1</span>)   <span class="comment">// 提取 [29:21] 位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">fn</span> <span class="title function_">p1_index</span>(vaddr: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    (vaddr &gt;&gt; <span class="number">12</span>) &amp; (ENTRY_COUNT - <span class="number">1</span>)         <span class="comment">// 提取 [20:12] 位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>地址分解原理：</strong></p>
<ul>
<li>x86-64的64位虚拟地址被分为5个部分：<ul>
<li><strong>[63:48]</strong>: 符号扩展位（必须与第47位相同）</li>
<li><strong>[47:39]</strong>: L4页表索引（9位，512个条目）</li>
<li><strong>[38:30]</strong>: L3页表索引（9位，512个条目）</li>
<li><strong>[29:21]</strong>: L2页表索引（9位，512个条目）</li>
<li><strong>[20:12]</strong>: L1页表索引（9位，512个条目）</li>
<li><strong>[11:0]</strong>: 页内偏移（12位，4KB页面）</li>
</ul>
</li>
</ul>
<h4 id="页表遍历核心逻辑"><a href="#页表遍历核心逻辑" class="headerlink" title="页表遍历核心逻辑"></a><strong>页表遍历核心逻辑</strong></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/memory/paging.rs:280-318</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_entry_mut_internal</span>(&amp;<span class="keyword">self</span>, vaddr: VA) <span class="punctuation">-&gt;</span> PagingResult&lt;(&amp;<span class="keyword">mut</span> PTE, PageTableLevel)&gt; &#123;</span><br><span class="line">    <span class="keyword">use</span> PageTableLevel::*;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vaddr</span> = vaddr.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="comment">// 1. 从L4页表根开始（相当于从CR3寄存器获取地址）</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p4</span> = table_of_mut::&lt;PTE&gt;(<span class="keyword">self</span>.<span class="title function_ invoke__">root_paddr</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p4e</span> = &amp;<span class="keyword">mut</span> p4[<span class="title function_ invoke__">p4_index</span>(vaddr)];</span><br><span class="line">    <span class="keyword">if</span> p4e.<span class="title function_ invoke__">is_unused</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>((p4e, L4));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> !p4e.<span class="title function_ invoke__">is_present</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(PagingError::UnexpectedError);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 进入L3页表</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p3</span> = table_of_mut::&lt;PTE&gt;(p4e.<span class="title function_ invoke__">addr</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p3e</span> = &amp;<span class="keyword">mut</span> p3[<span class="title function_ invoke__">p3_index</span>(vaddr)];</span><br><span class="line">    <span class="keyword">if</span> p3e.<span class="title function_ invoke__">is_unused</span>() || p3e.<span class="title function_ invoke__">is_leaf</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>((p3e, L3));  <span class="comment">// 可能是1GB大页</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> !p3e.<span class="title function_ invoke__">is_present</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(PagingError::UnexpectedError);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 进入L2页表</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = table_of_mut::&lt;PTE&gt;(p2e.<span class="title function_ invoke__">addr</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2e</span> = &amp;<span class="keyword">mut</span> p2[<span class="title function_ invoke__">p2_index</span>(vaddr)];</span><br><span class="line">    <span class="keyword">if</span> p2e.<span class="title function_ invoke__">is_unused</span>() || p2e.<span class="title function_ invoke__">is_leaf</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>((p2e, L2));  <span class="comment">// 可能是2MB大页</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> !p2e.<span class="title function_ invoke__">is_present</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(PagingError::UnexpectedError);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 进入L1页表（最终级别）</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = table_of_mut::&lt;PTE&gt;(p2e.<span class="title function_ invoke__">addr</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1e</span> = &amp;<span class="keyword">mut</span> p1[<span class="title function_ invoke__">p1_index</span>(vaddr)];</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>((p1e, L1))  <span class="comment">// 4KB页面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="地址查询接口"><a href="#地址查询接口" class="headerlink" title="地址查询接口"></a><strong>地址查询接口</strong></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/memory/paging.rs:217-230</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">GenericPageTableImmut</span>: <span class="built_in">Sized</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">VA</span>: <span class="built_in">From</span>&lt;<span class="type">usize</span>&gt; + <span class="built_in">Into</span>&lt;<span class="type">usize</span>&gt; + <span class="built_in">Copy</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">from_root</span>(root_paddr: PhysAddr) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">root_paddr</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> PhysAddr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 遍历页表获取有效的映射信息</span></span><br><span class="line">    <span class="comment">/// 返回：(物理地址, 内存标志, 页面大小)</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">query</span>(&amp;<span class="keyword">self</span>, vaddr: <span class="keyword">Self</span>::VA) <span class="punctuation">-&gt;</span> PagingResult&lt;(PhysAddr, MemFlags, PageSize)&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>query函数的实现：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/memory/paging.rs:406-420</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">query</span>(&amp;<span class="keyword">self</span>, vaddr: VA) <span class="punctuation">-&gt;</span> PagingResult&lt;(PhysAddr, MemFlags, PageSize)&gt; &#123;</span><br><span class="line">    <span class="comment">// 1. 获取页表项和级别</span></span><br><span class="line">    <span class="keyword">let</span> (entry, level) = <span class="keyword">self</span>.<span class="title function_ invoke__">get_entry_mut_internal</span>(vaddr)?;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 检查页表项是否被使用</span></span><br><span class="line">    <span class="keyword">if</span> entry.<span class="title function_ invoke__">is_unused</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(PagingError::<span class="title function_ invoke__">NotMapped</span>(vaddr.<span class="title function_ invoke__">into</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 获取页面大小</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">size</span> = level.<span class="title function_ invoke__">page_size</span>()?;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 检查页表项是否有效（Present位）</span></span><br><span class="line">    <span class="keyword">if</span> !entry.<span class="title function_ invoke__">is_present</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(PagingError::<span class="title function_ invoke__">NotPresent</span>((</span><br><span class="line">            vaddr.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            entry.<span class="title function_ invoke__">addr</span>(),</span><br><span class="line">            entry.<span class="title function_ invoke__">flags</span>(),</span><br><span class="line">            size,</span><br><span class="line">        )));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 计算最终物理地址 = 页面基址 + 页内偏移</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">off</span> = size.<span class="title function_ invoke__">page_offset</span>(vaddr.<span class="title function_ invoke__">into</span>());</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>((entry.<span class="title function_ invoke__">addr</span>() + off, entry.<span class="title function_ invoke__">flags</span>(), size))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="地址转换完整流程"><a href="#地址转换完整流程" class="headerlink" title="地址转换完整流程"></a><strong>地址转换完整流程</strong></h4><ol>
<li><strong>起始点</strong>: 从根页表（L4 Table）开始，根地址存储在<code>self.root_paddr()</code>中</li>
<li><strong>L4遍历</strong>: 使用虚拟地址的<code>[47:39]</code>位作为索引，在L4页表中找到L4 PTE</li>
<li><strong>L3遍历</strong>: 如果L4 PTE不是叶子节点，使用<code>[38:30]</code>位在L3页表中查找</li>
<li><strong>L2遍历</strong>: 如果L3 PTE不是叶子节点，使用<code>[29:21]</code>位在L2页表中查找  </li>
<li><strong>L1遍历</strong>: 如果L2 PTE不是叶子节点，使用<code>[20:12]</code>位在L1页表中查找</li>
<li><strong>最终地址</strong>: PTE的基址 + 虚拟地址的低12位（页内偏移）&#x3D; 最终物理地址</li>
</ol>
<h3 id="底层原理：MMU与CR3"><a href="#底层原理：MMU与CR3" class="headerlink" title="底层原理：MMU与CR3"></a>底层原理：MMU与CR3</h3><ul>
<li><p><code>query</code>函数是在<strong>软件中模拟</strong>了CPU硬件<strong>MMU（内存管理单元）</strong>的工作流程。</p>
</li>
<li><p>在真实运行时，Hypervisor通过<code>activate()</code>方法将根页表的物理地址加载到<code>CR3</code>寄存器中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码，实际由x86_64库提供</span></span><br><span class="line">asm!(<span class="string">&quot;mov cr3, &#123;&#125;&quot;</span>, <span class="title function_ invoke__">in</span>(reg) root_paddr);</span><br></pre></td></tr></table></figure>
</li>
<li><p>之后，每一次内存访问，CPU的MMU都会自动、硬件级地执行上述<code>query</code>函数中的页表遍历过程，以极高的速度完成地址翻译。如果翻译失败（例如PTE的<code>Present</code>位为0），MMU会触发一个<strong>Page Fault</strong>异常，将控制权交还给Hypervisor的处理程序。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>PTE的核心作用：</p>
<ol>
<li>地址映射: 记录虚拟地址到物理地址的映射关系</li>
<li>权限控制: 记录内存页面的访问权限（读&#x2F;写&#x2F;执行&#x2F;用户&#x2F;加密等）</li>
<li>状态管理: 记录页面状态（是否存在、是否被访问、是否为大页等）</li>
<li>硬件接口: 作为软件与CPU硬件MMU之间的数据结构</li>
</ol>
<blockquote>
<p>这块如果你之前不是很了解 linux 的 MMU 或者不太清楚 HyperEnclave的宏观地址转换架构（这个文章后面会说），直接说细节可能很难理解透。</p>
</blockquote>
<h2 id="5-第四层：高级内存映射-mm-rs-mapper-rs"><a href="#5-第四层：高级内存映射-mm-rs-mapper-rs" class="headerlink" title="5. 第四层：高级内存映射 (mm.rs, mapper.rs)"></a>5. 第四层：高级内存映射 (<code>mm.rs</code>, <code>mapper.rs</code>)</h2><p>这一层提供了面向开发者的、更易于使用的API，将物理帧分配和页表操作封装在一起。</p>
<h3 id="核心数据结构-1"><a href="#核心数据结构-1" class="headerlink" title="核心数据结构"></a>核心数据结构</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/memory/mm.rs:35-42</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MemorySet</span>&lt;PT: GenericPageTable&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    PT::VA: <span class="built_in">Ord</span>,</span><br><span class="line">&#123;</span><br><span class="line">    regions: BTreeMap&lt;PT::VA, MemoryRegion&lt;PT::VA&gt;&gt;,</span><br><span class="line">    pt: PT, <span class="comment">// 内含一个页表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MemorySet</code>代表一个完整的地址空间（如一个Enclave的地址空间）。它包含一个页表（<code>pt</code>）和多个<code>MemoryRegion</code>。<code>MemoryRegion</code>定义了一个连续的虚拟内存区域及其属性。</p>
<h3 id="核心逻辑：MemorySet-insert"><a href="#核心逻辑：MemorySet-insert" class="headerlink" title="核心逻辑：MemorySet::insert"></a>核心逻辑：<code>MemorySet::insert</code></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/memory/mm.rs:85-94 (simplified)</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">insert</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, region: MemoryRegion&lt;PT::VA&gt;) <span class="punctuation">-&gt;</span> HvResult &#123;</span><br><span class="line">    <span class="comment">// 1. 检查虚拟地址区域是否与其他区域重叠</span></span><br><span class="line">    <span class="keyword">if</span> !<span class="keyword">self</span>.<span class="title function_ invoke__">test_free_area</span>(&amp;region) &#123;</span><br><span class="line">        <span class="keyword">return</span> hv_result_err!(EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 调用页表层的map函数</span></span><br><span class="line">    <span class="keyword">self</span>.pt.<span class="title function_ invoke__">map</span>(&amp;region)?; </span><br><span class="line">    <span class="comment">// 3. 将区域信息存入BTreeMap</span></span><br><span class="line">    <span class="keyword">self</span>.regions.<span class="title function_ invoke__">insert</span>(region.start, region);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>self.pt.map(&amp;region)</code>是关键，它内部会：</p>
<ol>
<li>遍历<code>region</code>中的每一个虚拟页面。</li>
<li>为每个虚拟页面调用<code>frame::alloc()</code>分配一个物理帧。</li>
<li>计算出PTE应该在页表中的位置。</li>
<li>创建一个PTE，将虚拟页面链接到分配的物理帧，并设置好<code>region.flags</code>中指定的权限。</li>
</ol>
<h3 id="底层原理：从API到硬件"><a href="#底层原理：从API到硬件" class="headerlink" title="底层原理：从API到硬件"></a>底层原理：从API到硬件</h3><p>一个<code>MemorySet::insert</code>调用最终会转化为一系列底层的CPU操作：</p>
<ol>
<li><strong>软件簿记</strong>：更新<code>FrameAllocator</code>的位图。</li>
<li><strong>内存写操作</strong>：修改多级页表中的PTE内容。</li>
<li><strong>TLB刷新</strong>：执行<code>invlpg</code>指令使TLB（快表）中的旧缓存失效，确保CPU使用最新的页表映射。</li>
</ol>
<h2 id="6-第五层：Enclave可转换内存管理-cmr-rs"><a href="#6-第五层：Enclave可转换内存管理-cmr-rs" class="headerlink" title="6. 第五层：Enclave可转换内存管理 (cmr.rs)"></a>6. 第五层：Enclave可转换内存管理 (<code>cmr.rs</code>)</h2><p>这是HyperEnclave最具特色的部分，专门用于管理Enclave的安全内存（EPC）。</p>
<h3 id="设计思想：可转换内存"><a href="#设计思想：可转换内存" class="headerlink" title="设计思想：可转换内存"></a>设计思想：可转换内存</h3><p>HyperEnclave不静态划分普通内存和安全内存，而是提出<strong>可转换内存（Convertible Memory）</strong>的概念。这意味着一块物理内存页可以在运行时被动态地转换为普通内存、EPC安全内存或Hypervisor内部内存。</p>
<h3 id="核心数据结构-2"><a href="#核心数据结构-2" class="headerlink" title="核心数据结构"></a>核心数据结构</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/memory/cmr.rs:59-71</span></span><br><span class="line"><span class="meta">#[repr(u8)]</span></span><br><span class="line"><span class="meta">#[derive(Clone, Copy, Debug, Eq, PartialEq)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">PageStatus</span> &#123;</span><br><span class="line">    Reserved = <span class="number">0</span>,</span><br><span class="line">    _Pending = <span class="number">1</span>,</span><br><span class="line">    Normal = <span class="number">2</span>,</span><br><span class="line">    Secure = <span class="number">3</span>, <span class="comment">// EPC 页面</span></span><br><span class="line">    Internal = <span class="number">4</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/memory/cmr.rs:74-77</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CmrmEntry</span> &#123;</span><br><span class="line">    page_status: PageStatus,</span><br><span class="line">    _inner: [<span class="type">u8</span>; <span class="number">23</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ConvMemManager</code>为系统中<strong>每一页</strong>可转换的物理内存维护一个<code>CmrmEntry</code>元数据。这个巨大的元数据数组就是<strong>CMRM（Convertible Memory Region Metadata）</strong>。</li>
<li><code>CmrmEntry</code>的核心是<code>page_status</code>，它记录了对应物理页的当前类型。</li>
</ul>
<h3 id="核心逻辑：initialize-cmrm"><a href="#核心逻辑：initialize-cmrm" class="headerlink" title="核心逻辑：initialize_cmrm"></a>核心逻辑：<code>initialize_cmrm</code></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/memory/cmr.rs:172-210</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">initialize_cmrm</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, num: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> HyperCallResult&lt;<span class="type">usize</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">idx</span> <span class="keyword">in</span> start_idx..start_idx + num &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">paddr</span> = *CONV_MEM_START + idx * PAGE_SIZE;</span><br><span class="line">        <span class="comment">// 根据物理地址所在的预定义范围，判断其初始状态</span></span><br><span class="line">        <span class="keyword">self</span>.cmrm[idx].page_status = &#123;</span><br><span class="line">            <span class="keyword">if</span> ConvMemManager::<span class="title function_ invoke__">in_init_hypervior_mem</span>(paddr) &#123;</span><br><span class="line">                PageStatus::Internal</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ConvMemManager::<span class="title function_ invoke__">in_init_epc</span>(paddr, PAGE_SIZE) &#123;</span><br><span class="line">                PageStatus::Secure</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ConvMemManager::<span class="title function_ invoke__">in_conv_mem</span>(paddr, PAGE_SIZE) &#123;</span><br><span class="line">                PageStatus::Normal</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                PageStatus::Reserved</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数在Hypervisor启动时被调用，它遍历所有可转换内存，根据固件提供的信息（如哪些内存预留为初始EPC），为每个物理页设置其初始<code>PageStatus</code>。</p>
<h3 id="底层原理：安全内存的实现"><a href="#底层原理：安全内存的实现" class="headerlink" title="底层原理：安全内存的实现"></a>底层原理：安全内存的实现</h3><p>将一页普通内存转换为EPC安全内存的完整流程是：</p>
<ol>
<li><strong>软件层</strong>：调用<code>ConvMemManager</code>的接口，将对应<code>CmrmEntry</code>的<code>page_status</code>从<code>Normal</code>更新为<code>Secure</code>。</li>
<li><strong>页表层</strong>：找到映射到该物理页的PTE，并将其<code>MemFlags</code>添加<code>ENCRYPTED</code>标志。</li>
<li><strong>地址转换层</strong>：在构建最终PTE时，<code>phys_encrypted</code>函数会为该物理地址设置<code>C-bit</code>。</li>
<li><strong>硬件层</strong>：当MMU使用这个PTE进行地址翻译时，它将带有<code>C-bit</code>的物理地址发送到内存控制器。内存控制器识别到<code>C-bit</code>后，自动使用SEV引擎对该次内存访问进行加解密。</li>
</ol>
<h2 id="7-内存访问流程和地址转换架构"><a href="#7-内存访问流程和地址转换架构" class="headerlink" title="7.内存访问流程和地址转换架构"></a>7.内存访问流程和地址转换架构</h2><div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  graph TD
    subgraph &quot;Guest程序内存访问&quot;
        A1[Guest应用程序] --&gt; A2[Guest虚拟地址]
        A2 --&gt; A3[Guest页表遍历]
        A3 --&gt; A4[Guest物理地址]
        A4 --&gt; A5[Nested页表&#x2F;EPT]
        A5 --&gt; A6[实际物理内存]
    end
    
    subgraph &quot;Enclave程序内存访问&quot;
        B1[Enclave应用程序] --&gt; B2[Enclave虚拟地址]
        B2 --&gt; B3[Enclave Guest页表遍历]
        B3 --&gt; B4[Guest物理地址]
        B4 --&gt; B5[Nested页表&#x2F;EPT]
        B5 --&gt; B6[实际物理内存]
    end
    
    subgraph &quot;控制层次&quot;
        C1[Guest操作系统] --&gt; C2[管理Guest页表]
        C3[HyperEnclave] --&gt; C4[管理Enclave Guest页表]
        C3 --&gt; C5[管理Nested页表]
        C3 --&gt; C6[安全策略控制]
    end
  </pre></div>



<h3 id="7-1-Guest程序的内存访问机制"><a href="#7-1-Guest程序的内存访问机制" class="headerlink" title="7.1 Guest程序的内存访问机制"></a>7.1 Guest程序的内存访问机制</h3><h4 id="地址转换流程"><a href="#地址转换流程" class="headerlink" title="地址转换流程"></a>地址转换流程</h4><p>从代码分析可以看出，Guest程序的内存访问分为两种情况：</p>
<h4 id="普通Guest内存访问（NonSecure）"><a href="#普通Guest内存访问（NonSecure）" class="headerlink" title="普通Guest内存访问（NonSecure）"></a>普通Guest内存访问（NonSecure）</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/memory/gaccess.rs:215-227</span></span><br><span class="line">PtrType::<span class="title function_ invoke__">NonSecure</span>(untrusted_gpt) =&gt; <span class="keyword">match</span> untrusted_gpt.<span class="title function_ invoke__">query</span>(gvaddr) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>((gpaddr, mem_flags, pg_size)) =&gt; (gpaddr, mem_flags, pg_size),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(PagingError::<span class="title function_ invoke__">NotMapped</span>(_)) | <span class="title function_ invoke__">Err</span>(PagingError::<span class="title function_ invoke__">NotPresent</span>(_)) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(hypercall_excep_err!(</span><br><span class="line">            <span class="title function_ invoke__">generate_pf</span>(<span class="literal">false</span>),</span><br><span class="line">            <span class="built_in">format!</span>(<span class="string">&quot;Cannot get gpaddr for gvaddr: &#123;:#x?&#125;, inject #PF&quot;</span>, gvaddr)</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(HvError::<span class="title function_ invoke__">from</span>(e).<span class="title function_ invoke__">into</span>()),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>转换步骤</strong>：</p>
<ol>
<li><strong>Guest虚拟地址</strong> → Guest页表查询 → <strong>Guest物理地址</strong></li>
<li><strong>Guest物理地址</strong> → Nested页表（EPT&#x2F;NPT）→ <strong>实际物理内存</strong></li>
</ol>
<h4 id="页表遍历机制"><a href="#页表遍历机制" class="headerlink" title="页表遍历机制"></a>页表遍历机制</h4><p>Guest页表遍历通过四级页表结构实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/memory/paging.rs:865-880</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">fn</span> <span class="title function_">p4_index</span>(vaddr: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    (vaddr &gt;&gt; (<span class="number">12</span> + <span class="number">27</span>)) &amp; (ENTRY_COUNT - <span class="number">1</span>)  <span class="comment">// [47:39] 位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">fn</span> <span class="title function_">p3_index</span>(vaddr: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    (vaddr &gt;&gt; (<span class="number">12</span> + <span class="number">18</span>)) &amp; (ENTRY_COUNT - <span class="number">1</span>)  <span class="comment">// [38:30] 位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">fn</span> <span class="title function_">p2_index</span>(vaddr: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    (vaddr &gt;&gt; (<span class="number">12</span> + <span class="number">9</span>)) &amp; (ENTRY_COUNT - <span class="number">1</span>)   <span class="comment">// [29:21] 位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">fn</span> <span class="title function_">p1_index</span>(vaddr: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    (vaddr &gt;&gt; <span class="number">12</span>) &amp; (ENTRY_COUNT - <span class="number">1</span>)         <span class="comment">// [20:12] 位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-Enclave程序的内存访问机制"><a href="#7-2-Enclave程序的内存访问机制" class="headerlink" title="7.2. Enclave程序的内存访问机制"></a>7.2. Enclave程序的内存访问机制</h3><h4 id="特殊的地址转换"><a href="#特殊的地址转换" class="headerlink" title="特殊的地址转换"></a>特殊的地址转换</h4><p>Enclave程序的内存访问更复杂，需要额外的安全检查：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/memory/gaccess.rs:231-235</span></span><br><span class="line">PtrType::<span class="title function_ invoke__">Secure</span>(enclave) =&gt; &#123;</span><br><span class="line">    enclave.<span class="title function_ invoke__">load_page</span>(gvaddr, *cpu_state == CpuState::EnclaveRunning)?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Enclave页面加载机制"><a href="#Enclave页面加载机制" class="headerlink" title="Enclave页面加载机制"></a>Enclave页面加载机制</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/enclave/mod.rs:967-1009</span></span><br><span class="line"><span class="keyword">match</span> secure_gpt.<span class="title function_ invoke__">get_pte_mut</span>(gvaddr) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(pte) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> pte.<span class="title function_ invoke__">is_unused</span>() &#123;</span><br><span class="line">            <span class="comment">// 页面未映射，触发页面错误</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">error_code</span> = PageFaultErrorCode::USER_MODE.<span class="title function_ invoke__">bits</span>();</span><br><span class="line">            <span class="title function_ invoke__">generate_pf</span>(error_code, gvaddr, is_encl_mode)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> !pte.<span class="title function_ invoke__">is_present</span>() &#123;</span><br><span class="line">            <span class="comment">// 页面被回收，需要重新加载</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">gpaddr_aligned</span> = pte.<span class="title function_ invoke__">addr</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">new_sec_info</span> = EpcmManager::<span class="title function_ invoke__">access_page_check</span>(</span><br><span class="line">                gvaddr, gpaddr_aligned, <span class="keyword">self</span>, <span class="literal">false</span>, is_encl_mode,</span><br><span class="line">            )?;</span><br><span class="line">            pte.<span class="title function_ invoke__">set_flags</span>(new_sec_info.<span class="title function_ invoke__">into</span>(), <span class="literal">false</span>)?;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>((</span><br><span class="line">                gpaddr_aligned + PageSize::Size4K.<span class="title function_ invoke__">page_offset</span>(gvaddr),</span><br><span class="line">                pte.<span class="title function_ invoke__">flags</span>(),</span><br><span class="line">                PageSize::Size4K,</span><br><span class="line">            ))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 页面正常，直接返回</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">gpfn</span> = pte.<span class="title function_ invoke__">addr</span>();</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>((gpfn + PageSize::Size4K.<span class="title function_ invoke__">page_offset</span>(gvaddr), pte.<span class="title function_ invoke__">flags</span>(), PageSize::Size4K))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>转换步骤</strong>：</p>
<ol>
<li><strong>Enclave虚拟地址</strong> → Enclave Guest页表查询 → <strong>Guest物理地址</strong></li>
<li><strong>Guest物理地址</strong> → Nested页表（EPT&#x2F;NPT）→ <strong>实际物理内存</strong></li>
<li><strong>额外安全检查</strong>：EPCM验证、权限检查、状态验证</li>
</ol>
<h3 id="7-3-控制层次分析"><a href="#7-3-控制层次分析" class="headerlink" title="7.3. 控制层次分析"></a>7.3. 控制层次分析</h3><h4 id="7-3-1-Guest操作系统控制范围"><a href="#7-3-1-Guest操作系统控制范围" class="headerlink" title="7.3.1 Guest操作系统控制范围"></a>7.3.1 Guest操作系统控制范围</h4><p>Guest操作系统（Linux）控制的内容：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从代码推断Guest OS的控制范围</span></span><br><span class="line"><span class="comment">// Guest OS管理自己的页表，但受到HyperEnclave的监控</span></span><br></pre></td></tr></table></figure>

<p><strong>Guest OS控制</strong>：</p>
<ul>
<li><strong>Guest页表管理</strong>：创建、修改、删除Guest虚拟地址到Guest物理地址的映射</li>
<li><strong>内存分配</strong>：在Guest物理地址空间内分配内存给应用程序</li>
<li><strong>权限管理</strong>：设置页面的读写执行权限（受限）</li>
<li><strong>进程隔离</strong>：在Guest内部实现进程间的内存隔离</li>
</ul>
<p><strong>Guest OS无法控制</strong>：</p>
<ul>
<li>Nested页表（EPT&#x2F;NPT）</li>
<li>Enclave的内存管理</li>
<li>实际物理内存的分配</li>
<li>跨Guest的安全策略</li>
</ul>
<h4 id="7-3-2-HyperEnclave控制范围"><a href="#7-3-2-HyperEnclave控制范围" class="headerlink" title="7.3.2 HyperEnclave控制范围"></a>7.3.2 HyperEnclave控制范围</h4><p>从代码可以看出HyperEnclave的全面控制：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/cell.rs:27-36</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Cell</span> &#123;</span><br><span class="line">    <span class="comment">/// Guest physical memory set.</span></span><br><span class="line">    <span class="keyword">pub</span> gpm: MemorySet&lt;NestedPageTable&gt;,</span><br><span class="line">    <span class="comment">/// Host virtual memory set.</span></span><br><span class="line">    <span class="keyword">pub</span> hvm: MemorySet&lt;HostPageTable&gt;,</span><br><span class="line">    <span class="comment">/// DMA memory set.</span></span><br><span class="line">    <span class="keyword">pub</span> dma_regions: MemorySet&lt;IoPageTable&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HyperEnclave控制</strong>：</p>
<h5 id="1）Nested页表管理"><a href="#1）Nested页表管理" class="headerlink" title="1）Nested页表管理"></a>1）Nested页表管理</h5><ul>
<li><strong>二级地址转换</strong>：Guest物理地址 → 实际物理地址</li>
<li><strong>内存隔离</strong>：确保不同Guest无法访问对方内存</li>
<li><strong>访问权限</strong>：控制Guest对物理内存的访问权限</li>
</ul>
<h5 id="2）Enclave专用管理"><a href="#2）Enclave专用管理" class="headerlink" title="2）Enclave专用管理"></a>2）Enclave专用管理</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/enclave/mod.rs:170-175</span></span><br><span class="line"><span class="comment">/// Nested page table in S-world.</span></span><br><span class="line">npt: RwLock&lt;EnclaveNestedPageTableUnlocked&gt;,</span><br><span class="line"><span class="comment">/// Guest page table in S-world.</span></span><br><span class="line">gpt: RwLock&lt;EnclaveGuestPageTableUnlocked&gt;,</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Enclave Guest页表</strong>：专门为Enclave创建的页表</li>
<li><strong>EPCM管理</strong>：Enclave页面缓存映射管理</li>
<li><strong>安全策略</strong>：实施Enclave的安全隔离策略</li>
</ul>
<h5 id="3）内存安全验证"><a href="#3）内存安全验证" class="headerlink" title="3）内存安全验证"></a>3）内存安全验证</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/memory/gaccess.rs:140-158</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">check_gpaddr</span>(gpaddr: GuestPhysAddr, is_secure: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> HvResult &#123;</span><br><span class="line">    <span class="keyword">if</span> is_secure &#123;</span><br><span class="line">        <span class="keyword">if</span> !EpcmManager::<span class="title function_ invoke__">is_valid_epc</span>(gpaddr) &#123;</span><br><span class="line">            <span class="keyword">return</span> hv_result_err!(EINVAL, <span class="string">&quot;Cannot access guest paddr as secure memory&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> EpcmManager::<span class="title function_ invoke__">is_valid_epc</span>(gpaddr) </span><br><span class="line">        || !ROOT_CELL.<span class="title function_ invoke__">is_valid_normal_world_gpaddr</span>(gpaddr) &#123;</span><br><span class="line">        <span class="keyword">return</span> hv_result_err!(EINVAL, <span class="string">&quot;Cannot access guest paddr as non-secure memory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>地址验证</strong>：验证访问的物理地址是否合法</li>
<li><strong>安全边界</strong>：强制执行安全内存和非安全内存的边界</li>
<li><strong>访问控制</strong>：根据上下文控制内存访问权限</li>
</ul>
<h3 id="7-4-内存访问的完整流程图"><a href="#7-4-内存访问的完整流程图" class="headerlink" title="7.4 内存访问的完整流程图"></a>7.4 内存访问的完整流程图</h3><h4 id="Guest程序内存访问"><a href="#Guest程序内存访问" class="headerlink" title="Guest程序内存访问"></a>Guest程序内存访问</h4><div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  sequenceDiagram
    participant App as Guest应用
    participant OS as Guest OS
    participant HV as HyperEnclave
    participant HW as 硬件MMU

    App-&gt;&gt;HW: 访问虚拟地址
    HW-&gt;&gt;OS: 查询Guest页表
    OS-&gt;&gt;HW: 返回Guest物理地址
    HW-&gt;&gt;HV: 查询Nested页表
    HV-&gt;&gt;HW: 返回实际物理地址
    HW-&gt;&gt;App: 完成内存访问
  </pre></div>

<h4 id="Enclave程序内存访问"><a href="#Enclave程序内存访问" class="headerlink" title="Enclave程序内存访问"></a>Enclave程序内存访问</h4><div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  sequenceDiagram
    participant EApp as Enclave应用
    participant HV as HyperEnclave
    participant EPCM as EPCM管理器
    participant HW as 硬件MMU

    EApp-&gt;&gt;HW: 访问Enclave虚拟地址
    HW-&gt;&gt;HV: 查询Enclave Guest页表
    HV-&gt;&gt;EPCM: 验证页面状态和权限
    EPCM-&gt;&gt;HV: 返回验证结果
    HV-&gt;&gt;HW: 返回Guest物理地址
    HW-&gt;&gt;HV: 查询Nested页表
    HV-&gt;&gt;HW: 返回实际物理地址
    HW-&gt;&gt;EApp: 完成内存访问
  </pre></div>

<h4 id="关键差异总结"><a href="#关键差异总结" class="headerlink" title="关键差异总结"></a>关键差异总结</h4><table>
<thead>
<tr>
<th>特性</th>
<th>Guest程序</th>
<th>Enclave程序</th>
</tr>
</thead>
<tbody><tr>
<td><strong>页表管理</strong></td>
<td>Guest OS管理</td>
<td>HyperEnclave管理</td>
</tr>
<tr>
<td><strong>安全检查</strong></td>
<td>基本权限检查</td>
<td>EPCM + 权限 + 状态验证</td>
</tr>
<tr>
<td><strong>内存区域</strong></td>
<td>普通物理内存</td>
<td>EPC（加密页面缓存）</td>
</tr>
<tr>
<td><strong>隔离级别</strong></td>
<td>进程级隔离</td>
<td>硬件级加密隔离</td>
</tr>
<tr>
<td><strong>故障处理</strong></td>
<td>标准页面错误</td>
<td>特殊安全异常</td>
</tr>
<tr>
<td><strong>动态管理</strong></td>
<td>OS内存管理</td>
<td>HyperEnclave + EPCM</td>
</tr>
</tbody></table>
<p>这种设计确保了Enclave程序具有比普通Guest程序更强的安全保障，同时HyperEnclave通过控制关键的页表结构和安全策略，实现了对整个系统内存访问的全面管控。</p>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><p>HyperEnclave的内存管理是一个设计精良、层次分明的系统。</p>
<ul>
<li>它从最底层的<strong>物理帧位图</strong>开始。</li>
<li>通过<strong>多级页表</strong>和<strong>PTE抽象</strong>，构建了强大的虚拟内存机制。</li>
<li>利用**<code>MemorySet</code>**将其封装成易用的高级API。</li>
<li>最后通过创新的<strong>可转换内存模型（CMRM）</strong>，实现了对EPC安全内存的灵活、动态管理。</li>
</ul>
<p>整个系统的实现深度依赖于对x86-64硬件特性（如MMU、CR3、MSR、SEV加密位）的直接利用，并通过Rust的类型系统和抽象能力，将这些复杂的底层操作安全、清晰地组织起来。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">XR</div><div class="post-copyright__author_desc">一片叶、一朵云</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2025/07/23/HyperEnclave%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2025/07/23/HyperEnclave%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/')">HyperEnclave内存管理模块源码与原理分析</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/kongxiaoran/image-repo/blog20241226231130275.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/kongxiaoran/image-repo/blog20241226231130275.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/kongxiaoran/image-repo/blog20241226231143327.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/kongxiaoran/image-repo/blog20241226231143327.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2025/07/23/HyperEnclave%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=HyperEnclave内存管理模块源码与原理分析&amp;url=http://example.com/2025/07/23/HyperEnclave%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;pic=https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/20250722115459961.png" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">凌霄的博客</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/HyperEnclave/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>HyperEnclave<span class="tagsPageCount">5</span></a><a class="post-meta__box__tags" href="/tags/TEE/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>TEE<span class="tagsPageCount">9</span></a><a class="post-meta__box__tags" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>内存管理<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/image-20250924140004853.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/07/23/Hypervisor%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90%EF%BC%9A%E4%BC%A0%E7%BB%9F%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EHyperEnclave/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/92e4b61997e43bfa9f726cfce3b0b5ef.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Hypervisor技术解析：传统虚拟化技术与HyperEnclave</div></div></a></div><div class="next-post pull-right"><a href="/2025/07/24/RSA_Explained/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/0657f362c75db694f40e01dcca53753b.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">深入理解RSA：加密与签名的艺术</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/07/18/HyperEnclave%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E5%9B%BE/" title="HyperEnclave源码学习路线图"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/20250722115418384.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-07-18</div><div class="title">HyperEnclave源码学习路线图</div></div></a></div><div><a href="/2025/07/21/HyperEnclave%E5%90%AF%E5%8A%A8%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/" title="HyperEnclave启动和初始化流程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/20250721161224869.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-07-21</div><div class="title">HyperEnclave启动和初始化流程</div></div></a></div><div><a href="/2025/07/20/HyperEnclave%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97%E8%A7%A3%E6%9E%90%EF%BC%9A%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86%E3%80%81%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%E4%B8%8E%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%94/" title="HyperEnclave机密计算解析：架构原理、安全机制与技术对比"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/20250721154750949.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-07-20</div><div class="title">HyperEnclave机密计算解析：架构原理、安全机制与技术对比</div></div></a></div><div><a href="/2025/07/19/HyperEnclave%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%BC%80%E6%94%BE%E4%B8%94%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%8F%AF%E4%BF%A1%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/" title="HyperEnclave：一个开放且跨平台的可信执行环境"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/20250624000019253.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-07-19</div><div class="title">HyperEnclave：一个开放且跨平台的可信执行环境</div></div></a></div><div><a href="/2025/06/26/confidential_computing_implementation_guide/" title="机密计算环境实施：从硬件选型到应用部署"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/20250625095124143.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-06-26</div><div class="title">机密计算环境实施：从硬件选型到应用部署</div></div></a></div><div><a href="/2025/06/24/confidential_computing_overview/" title="从物理攻击到云端信任：让我们一起了解可信执行环境与机密计算技术栈"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/20250625095124143.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-06-24</div><div class="title">从物理攻击到云端信任：让我们一起了解可信执行环境与机密计算技术栈</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">XR</h1><div class="author-info__desc">一片叶、一朵云</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/kongxiaoran" target="_blank" title="Github"></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HyperEnclave%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E4%B8%8E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">HyperEnclave内存管理模块源码与原理分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">1.1.</span> <span class="toc-text">目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.</span> <span class="toc-text">1. 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6"><span class="toc-number">1.2.1.</span> <span class="toc-text">设计哲学</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">模块结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AC%AC%E4%B8%80%E5%B1%82%EF%BC%9A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-frame-rs"><span class="toc-number">1.3.</span> <span class="toc-text">2. 第一层：物理内存管理 (frame.rs)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.1.</span> <span class="toc-text">核心数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E4%B8%8E%E9%87%8A%E6%94%BE"><span class="toc-number">1.3.2.</span> <span class="toc-text">分配与释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.3.</span> <span class="toc-text">底层原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%AC%AC%E4%BA%8C%E5%B1%82%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E4%B8%8E%E6%9D%83%E9%99%90-addr-rs-mod-rs"><span class="toc-number">1.4.</span> <span class="toc-text">3. 第二层：虚拟地址与权限 (addr.rs, mod.rs)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%AE%9A%E4%B9%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">地址空间定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%8A%A0%E5%AF%86"><span class="toc-number">1.4.2.</span> <span class="toc-text">地址转换与加密</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%B8%80%EF%BC%9AHypervisor%E8%87%AA%E8%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">场景一：Hypervisor自身内存的线性地址转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%BA%8C%EF%BC%9AGuest%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E9%80%9A%E7%94%A8%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">场景二：Guest虚拟机的通用地址转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%8A%A0%E5%AF%86%E6%A0%87%E8%AE%B0"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">物理地址的硬件加密标记</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%9D%83%E9%99%90%E6%A0%87%E5%BF%97"><span class="toc-number">1.4.3.</span> <span class="toc-text">内存权限标志</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%AC%AC%E4%B8%89%E5%B1%82%EF%BC%9A%E9%A1%B5%E8%A1%A8%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6-paging-rs"><span class="toc-number">1.5.</span> <span class="toc-text">4. 第三层：页表核心机制 (paging.rs)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%8A%BD%E8%B1%A1%EF%BC%9AGenericPTE"><span class="toc-number">1.5.1.</span> <span class="toc-text">核心抽象：GenericPTE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9ALevel4PageTable"><span class="toc-number">1.5.2.</span> <span class="toc-text">数据结构：Level4PageTable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.5.3.</span> <span class="toc-text">地址转换机制详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%B4%A2%E5%BC%95%E6%8F%90%E5%8F%96"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">虚拟地址索引提取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E9%81%8D%E5%8E%86%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">页表遍历核心逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E6%9F%A5%E8%AF%A2%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">地址查询接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B"><span class="toc-number">1.5.3.4.</span> <span class="toc-text">地址转换完整流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9AMMU%E4%B8%8ECR3"><span class="toc-number">1.5.4.</span> <span class="toc-text">底层原理：MMU与CR3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%AC%AC%E5%9B%9B%E5%B1%82%EF%BC%9A%E9%AB%98%E7%BA%A7%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84-mm-rs-mapper-rs"><span class="toc-number">1.6.</span> <span class="toc-text">5. 第四层：高级内存映射 (mm.rs, mapper.rs)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="toc-number">1.6.1.</span> <span class="toc-text">核心数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91%EF%BC%9AMemorySet-insert"><span class="toc-number">1.6.2.</span> <span class="toc-text">核心逻辑：MemorySet::insert</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9A%E4%BB%8EAPI%E5%88%B0%E7%A1%AC%E4%BB%B6"><span class="toc-number">1.6.3.</span> <span class="toc-text">底层原理：从API到硬件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%AC%AC%E4%BA%94%E5%B1%82%EF%BC%9AEnclave%E5%8F%AF%E8%BD%AC%E6%8D%A2%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-cmr-rs"><span class="toc-number">1.7.</span> <span class="toc-text">6. 第五层：Enclave可转换内存管理 (cmr.rs)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%EF%BC%9A%E5%8F%AF%E8%BD%AC%E6%8D%A2%E5%86%85%E5%AD%98"><span class="toc-number">1.7.1.</span> <span class="toc-text">设计思想：可转换内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2"><span class="toc-number">1.7.2.</span> <span class="toc-text">核心数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91%EF%BC%9Ainitialize-cmrm"><span class="toc-number">1.7.3.</span> <span class="toc-text">核心逻辑：initialize_cmrm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9A%E5%AE%89%E5%85%A8%E5%86%85%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.4.</span> <span class="toc-text">底层原理：安全内存的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B%E5%92%8C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E6%9E%B6%E6%9E%84"><span class="toc-number">1.8.</span> <span class="toc-text">7.内存访问流程和地址转换架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-Guest%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E6%9C%BA%E5%88%B6"><span class="toc-number">1.8.1.</span> <span class="toc-text">7.1 Guest程序的内存访问机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%A8%8B"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">地址转换流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9AGuest%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%EF%BC%88NonSecure%EF%BC%89"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">普通Guest内存访问（NonSecure）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E9%81%8D%E5%8E%86%E6%9C%BA%E5%88%B6"><span class="toc-number">1.8.1.3.</span> <span class="toc-text">页表遍历机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-Enclave%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E6%9C%BA%E5%88%B6"><span class="toc-number">1.8.2.</span> <span class="toc-text">7.2. Enclave程序的内存访问机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">特殊的地址转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Enclave%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">Enclave页面加载机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E6%8E%A7%E5%88%B6%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90"><span class="toc-number">1.8.3.</span> <span class="toc-text">7.3. 控制层次分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-1-Guest%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6%E8%8C%83%E5%9B%B4"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">7.3.1 Guest操作系统控制范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-2-HyperEnclave%E6%8E%A7%E5%88%B6%E8%8C%83%E5%9B%B4"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">7.3.2 HyperEnclave控制范围</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89Nested%E9%A1%B5%E8%A1%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.8.3.2.1.</span> <span class="toc-text">1）Nested页表管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89Enclave%E4%B8%93%E7%94%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.8.3.2.2.</span> <span class="toc-text">2）Enclave专用管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%89%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E9%AA%8C%E8%AF%81"><span class="toc-number">1.8.3.2.3.</span> <span class="toc-text">3）内存安全验证</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E7%9A%84%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">1.8.4.</span> <span class="toc-text">7.4 内存访问的完整流程图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Guest%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">Guest程序内存访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Enclave%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE"><span class="toc-number">1.8.4.2.</span> <span class="toc-text">Enclave程序内存访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%B7%AE%E5%BC%82%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.4.3.</span> <span class="toc-text">关键差异总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%80%BB%E7%BB%93"><span class="toc-number">1.9.</span> <span class="toc-text">8. 总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/09/24/%E9%9A%90%E8%AF%ADSecretflow%E2%80%94%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E4%BD%93%E9%AA%8C/" title="隐语Secretflow—源码编译安装体验"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/image-20250924140004853.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="隐语Secretflow—源码编译安装体验"/></a><div class="content"><a class="title" href="/2025/09/24/%E9%9A%90%E8%AF%ADSecretflow%E2%80%94%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E4%BD%93%E9%AA%8C/" title="隐语Secretflow—源码编译安装体验">隐语Secretflow—源码编译安装体验</a><time datetime="2025-09-24T06:00:00.000Z" title="发表于 2025-09-24 14:00:00">2025-09-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/22/DNS%E6%8A%95%E6%AF%92%E5%8E%9F%E7%90%86%E4%B8%8E%E8%BF%87%E7%A8%8B/" title="DNS投毒原理与过程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/20250716144607754.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DNS投毒原理与过程"/></a><div class="content"><a class="title" href="/2025/09/22/DNS%E6%8A%95%E6%AF%92%E5%8E%9F%E7%90%86%E4%B8%8E%E8%BF%87%E7%A8%8B/" title="DNS投毒原理与过程">DNS投毒原理与过程</a><time datetime="2025-09-22T13:30:00.000Z" title="发表于 2025-09-22 21:30:00">2025-09-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%B2%E7%83%A7/" title="计算机网络核心概念串烧"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/09c33b5dbe1bd3fec63ad2e4128b55b6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络核心概念串烧"/></a><div class="content"><a class="title" href="/2025/09/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%B2%E7%83%A7/" title="计算机网络核心概念串烧">计算机网络核心概念串烧</a><time datetime="2025-09-22T02:00:00.000Z" title="发表于 2025-09-22 10:00:00">2025-09-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/20/Linux_%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97%E5%88%86%E7%B1%BB%E5%8F%8A%E8%AF%B4%E6%98%8E/" title="Linux 常见系统日志分类及说明"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/20250804092337513.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux 常见系统日志分类及说明"/></a><div class="content"><a class="title" href="/2025/09/20/Linux_%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97%E5%88%86%E7%B1%BB%E5%8F%8A%E8%AF%B4%E6%98%8E/" title="Linux 常见系统日志分类及说明">Linux 常见系统日志分类及说明</a><time datetime="2025-09-20T13:30:00.000Z" title="发表于 2025-09-20 21:30:00">2025-09-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/20/debain%E6%9C%8D%E5%8A%A1%E5%99%A8%20%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E6%97%A5%E5%BF%97%E5%BD%92%E6%A1%A3%E6%96%87%E4%BB%B6%E6%B8%85%E7%90%86/" title="debain服务器 守护进程日志归档文件清理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/20250716144607754.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="debain服务器 守护进程日志归档文件清理"/></a><div class="content"><a class="title" href="/2025/09/20/debain%E6%9C%8D%E5%8A%A1%E5%99%A8%20%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E6%97%A5%E5%BF%97%E5%BD%92%E6%A1%A3%E6%96%87%E4%BB%B6%E6%B8%85%E7%90%86/" title="debain服务器 守护进程日志归档文件清理">debain服务器 守护进程日志归档文件清理</a><time datetime="2025-09-20T12:30:00.000Z" title="发表于 2025-09-20 20:30:00">2025-09-20</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2024 - 2025 By <a class="footer-bar-link" href="/" title="XR" target="_blank">XR</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">67</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">96</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">7</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Argon2/" style="font-size: 0.88rem;">Argon2<sup>1</sup></a><a href="/tags/DNS/" style="font-size: 0.88rem;">DNS<sup>4</sup></a><a href="/tags/HBase/" style="font-size: 0.88rem;">HBase<sup>1</sup></a><a href="/tags/HDFS/" style="font-size: 0.88rem;">HDFS<sup>4</sup></a><a href="/tags/HTTP/" style="font-size: 0.88rem;">HTTP<sup>1</sup></a><a href="/tags/Hadoop/" style="font-size: 0.88rem;">Hadoop<sup>4</sup></a><a href="/tags/Hive/" style="font-size: 0.88rem;">Hive<sup>1</sup></a><a href="/tags/HyperEnclave/" style="font-size: 0.88rem;">HyperEnclave<sup>5</sup></a><a href="/tags/Java/" style="font-size: 0.88rem;">Java<sup>8</sup></a><a href="/tags/Kubernetes/" style="font-size: 0.88rem;">Kubernetes<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>7</sup></a><a href="/tags/Maven/" style="font-size: 0.88rem;">Maven<sup>1</sup></a><a href="/tags/NAT/" style="font-size: 0.88rem;">NAT<sup>1</sup></a><a href="/tags/RDD/" style="font-size: 0.88rem;">RDD<sup>2</sup></a><a href="/tags/SGX/" style="font-size: 0.88rem;">SGX<sup>2</sup></a><a href="/tags/Spark/" style="font-size: 0.88rem;">Spark<sup>11</sup></a><a href="/tags/Spring/" style="font-size: 0.88rem;">Spring<sup>3</sup></a><a href="/tags/TDX/" style="font-size: 0.88rem;">TDX<sup>2</sup></a><a href="/tags/TEE/" style="font-size: 0.88rem;">TEE<sup>9</sup></a><a href="/tags/TME/" style="font-size: 0.88rem;">TME<sup>2</sup></a><a href="/tags/YARN/" style="font-size: 0.88rem;">YARN<sup>1</sup></a><a href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" style="font-size: 0.88rem;">云原生<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 0.88rem;">代理<sup>1</sup></a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/" style="font-size: 0.88rem;">分布式存储<sup>2</sup></a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/" style="font-size: 0.88rem;">分布式计算<sup>3</sup></a><a href="/tags/%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E9%99%90%E5%88%B6/" style="font-size: 0.88rem;">地理位置限制<sup>1</sup></a><a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 0.88rem;">大数据<sup>7</sup></a><a href="/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/" style="font-size: 0.88rem;">学习路线<sup>1</sup></a><a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 0.88rem;">安全<sup>2</sup></a><a href="/tags/%E5%AF%86%E7%A0%81%E5%93%88%E5%B8%8C/" style="font-size: 0.88rem;">密码哈希<sup>1</sup></a><a href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" style="font-size: 0.88rem;">密码学<sup>5</sup></a><a href="/tags/%E6%8A%80%E6%9C%AF%E4%B8%93%E6%A0%8F/" style="font-size: 0.88rem;">技术专栏<sup>1</sup></a><a href="/tags/%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97/" style="font-size: 0.88rem;">机密计算<sup>2</sup></a><a href="/tags/%E6%B5%81%E5%AA%92%E4%BD%93%E8%A7%A3%E9%94%81/" style="font-size: 0.88rem;">流媒体解锁<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">网络<sup>4</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90/" style="font-size: 0.88rem;">网络分析<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" style="font-size: 0.88rem;">网络安全<sup>1</sup></a><a href="/tags/%E9%98%B2%E7%81%AB%E5%A2%99/" style="font-size: 0.88rem;">防火墙<sup>2</sup></a><a href="/tags/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/" style="font-size: 0.88rem;">隐私计算<sup>4</sup></a><a href="/tags/%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84/" style="font-size: 0.88rem;">集群架构<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("12/26/2024 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2024 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 XR 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.cbd.int/mermaid@10.2.4/dist/mermaid.min.js').then(runMermaid)
  }

  anzhiyu.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'cbSQtAqs68yENzUQ5wpQK826-MdYXbMMI',
      appKey: 'MR93sqmbPdh7Zm1bZzjXNvlm',
      avatar: 'mp',
      serverURLs: 'https://cbsqtaqs.api.lncldglobal.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script src="https://cdn.cbd.int/blueimp-md5@2.19.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=mp'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://cbsqtaqs.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": 'cbSQtAqs68yENzUQ5wpQK826-MdYXbMMI',
        "X-LC-Key": 'MR93sqmbPdh7Zm1bZzjXNvlm',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>