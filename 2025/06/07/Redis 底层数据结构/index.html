<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Redis 底层数据结构 | 凌霄的博客</title><meta name="author" content="XR"><meta name="copyright" content="XR"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Redis 底层数据结构"><meta name="application-name" content="Redis 底层数据结构"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Redis 底层数据结构"><meta property="og:url" content="http://example.com/2025/06/07/Redis%20%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html"><meta property="og:site_name" content="凌霄的博客"><meta property="og:description" content="Redis 底层数据结构"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/20250607204045262.png"><meta property="article:author" content="XR"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/20250607204045262.png"><meta name="description" content="Redis 底层数据结构"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2025/06/07/Redis%20%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🧱 团队小组发动机"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: XR","link":"链接: ","source":"来源: 凌霄的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '凌霄的博客',
  title: 'Redis 底层数据结构',
  postAI: '',
  pageFillDescription: 'Redis 底层数据结构, 1. 底层数据结构引入, , 2. 简单动态字符串 - sds, 2.1. SDS 定义, 2.2. 为什么使用SDS, 2.3. 空间预分配补进一步理解, 2.4. 小结, 3. 压缩列表 - ZipList, 3.1. ziplist结构, 3.2. Entry结构, 3.3. 为什么ZipList特别省内存, 3.4. ziplist的缺点, 4. 快表 - QuickList, 4.1. quicklist结构, 4.2. quicklist内存布局图, 4.3. quicklist更多额外信息, 5. 字典x2F哈希表 - Dict, 5.1. 数据结构, 5.2. 一些要点, 6. 整数集 - IntSet, 6.1. intset结构, 6.2. 内存布局图, 6.3. 整数集合的升级, 7. 跳表 - ZSkipList, 7.1. 什么是跳跃表, 7.2. Redis跳跃表的设计, 7.3. 为什么不用平衡树或者哈希表, 8. 参考文章底层数据结构原文拷贝底层数据结构引入在对对象机制有了初步认识之后我们便可以继续理解如下的底层数据结构部分简单动态字符串压缩列表快表字典哈希表整数集跳表简单动态字符串是用语言写的但是对于的字符串却不是语言中的字符串即以空字符结尾的字符数组它是自己构建了一种名为简单动态字符串的抽象类型并将作为的默认字符串表示定义这是一种用于存储二进制数据的一种结构具有动态扩容的特点其实现位于与中的总体概览如下图其中是头部是真实存储用户数据的地方另外注意从命名上能看出来这个数据结构除了能存储二进制数据显然是用于设计作为字符串使用的所以在中用户数据后总跟着一个即图中数据是为所谓的如下是源码中相关的结构通过上图我们可以看到有五种不同的头部其中实际并未使用到所以实际上有四种不同的头部分别如下其中保存了保存字符串的长度数组用来保存字符串的每个元素分别以表示整个除过头部与末尾的剩余的字节数始终为一字节以低三位标示着头部的类型高位未使用为什么使用为什么不使用语言字符串实现而是使用呢这样实现有什么好处常数复杂度获取字符串长度由于属性的存在我们获取字符串的长度只需要读取属性时间复杂度为而对于语言获取字符串的长度通常是经过遍历计数来实现的时间复杂度为通过命令可以获取的字符串长度杜绝缓冲区溢出我们知道在语言中使用函数来进行两个字符串的拼接一旦没有分配足够长度的内存空间就会造成缓冲区溢出而对于数据类型在进行字符修改的时候会首先根据记录的属性检查内存空间是否满足需求如果不满足会进行相应的空间扩展然后在进行修改操作所以不会出现缓冲区溢出减少修改字符串的内存重新分配次数语言由于不记录字符串的长度所以如果要修改字符串必须要重新分配内存先释放再申请因为如果没有重新分配字符串长度增大时会造成内存缓冲区溢出字符串长度减小时会造成内存泄露而对于由于属性和属性的存在对于修改字符串实现了空间预分配和惰性空间释放两种策略空间预分配对字符串进行空间扩展的时候扩展的内存比实际需要的多这样可以减少连续执行字符串增长操作所需的内存重分配次数惰性空间释放对字符串进行缩短操作时程序不立即使用内存重新分配来回收缩短后多余的字节而是使用属性将这些字节的数量记录下来等待后续使用当然也提供了相应的当我们有需要时也可以手动释放这些未使用的空间二进制安全因为字符串以空字符作为字符串结束的标识而对于一些二进制文件如图片等内容可能包括空字符串因此字符串无法正确存取而所有的都是以处理二进制的方式来处理里面的元素并且不是以空字符串来判断是否结束而是以属性表示的长度来判断字符串是否结束兼容部分字符串函数虽然是二进制安全的但是一样遵从每个字符串都是以空字符串结尾的惯例这样可以重用语言库中的一部分函数空间预分配补进一步理解当执行追加操作时比如现在给的字符串后追加则这时的由变成了此时的表示空格也就是的内存空间是个字节其中占个字节给字符串多分配了个字节的预分配空间所以下次还有追加的时候如果预分配空间足够就无须在进行空间分配了在当前版本中当新字符串的长度小于时会分配他们所需大小一倍的空间当大于的时候就为他们额外多分配的空间思考这种分配策略会浪费内存资源吗答执行过命令的字符串会带有额外的预分配空间这些预分配空间不会被释放除非该字符串所对应的键被删除或者等到关闭之后再次启动时重新载入的字符串对象将不会有预分配空间因为执行命令的字符串键数量通常并不多占用内存的体积通常也不大所以这一般并不算什么问题另一方面如果执行操作的键很多而字符串的体积又很大的话那可能就需要修改服务器让它定时释放一些字符串键的预分配空间从而更有效地使用内存小结的字符串表示为而不是字符串以结尾的它是底层所使用的字符串表示它被用在几乎所有的模块中可以看如下对比一般来说除了保存数据库中的字符串值以外还可以作为缓冲区包括模块中的缓冲区以及客户端状态中的输入缓冲区压缩列表是为了提高存储效率而设计的一种特殊编码的双向链表它可以存储字符串或者整数存储整数时是采用整数的二进制而不是字符串形式存储它能在的时间复杂度下完成两端的和操作但是因为每次操作都需要重新分配的内存所以实际复杂度和的内存使用量相关结构先看下中对应的源码和介绍整个在内存中的存储格式如下字段的类型是这个字段中存储的是整个所占用的内存的字节数字段的类型是它指的是中最后一个的偏移量用于快速定位最后一个以快速完成等操作字段的类型是它指的是整个中的数量这个值只占位如果中的数目小于的次方那么该字段中存储的就是实际的值若等于或超过那么该字段的值固定为但实际数量需要一个个的去遍历所有才能得到是一个终止字节其值为全即保证任何情况下一个的首字节都不会是结构那么是什么结构呢先看下源码中相关介绍第一种情况一般结构前一个的大小编码方式见下文不同的情况下值不同用于表示当前的类型和长度真是用于存储表示的数据第二种情况在中存储的是类型时和会合并在中表示此时没有字段中在存储数据时会先尝试将转换成存储节省空间此时结构编码当前一个元素长度小于用于的时候长度为个字节值即为前一个的长度如果长度大于等于的时候用个字节表示第一字节设置为后面个字节存储一个小端的无符号整型表示前一个的长度长度小于结构长度大于等于编码的长度和值根据保存的是还是还有数据的长度而定前两位用来表示类型当为时表示存储的是类型其它表示存储的是存储时此时长度为个字节该字节的后六位表示中存储的长度因为是位所以中存储的长度不能超过此时长度为两个字节此时的后位用来存储长度长度不能超过此时长度为个字节后面的个字节用来表示中存储的字符串长度长度不能超过存储时为个字节后个字节表示一个为个字节后个字节表示一个为个字节后字节表示一个为个字节后个字节表示一个有符号整型为字节后个字节表示一个有符号整型长度就只有个字节表示一个的整数值还记得么源码中数据结构支撑你可以看到为了操作上的简易实际还增加了几个属性表示字段的长度表示字段存储的内容表示字段的长度表示数据内容长度表示当前元素的首部长度即字段长度与字段长度之和表示数据类型表示当前元素首地址为什么特别省内存所以只有理解上面的结构我们才会真正理解为什么是特别节省内存的数据结构节省内存是相对于普通的来说的如果是普通的数组那么它每个元素占用的内存是一样的且取决于最大的那个元素很明显它是需要预留空间的所以在设计时就很容易想到要尽量让每个元素按照实际的内容大小存储所以增加字段针对不同的来细化存储大小这时候还需要解决的一个问题是遍历元素时如何定位下一个元素呢在普通数组中每个元素定长所以不需要考虑这个问题但是中每个占据的内存不一样所以为了解决遍历需要增加记录上一个元素的所以增加了字段为什么我们去研究特别节省内存的数据结构在实际应用中大量存储字符串的优化是需要你对底层的数据结构有一定的理解的而在场景优化的时候也被考虑采用的首选的缺点最后我们再看看它的一些缺点也不预留内存空间并且在移除结点后也是立即缩容这代表每次写操作都会进行内存分配操作结点如果扩容导致结点占用的内存增长并且超过字节的话可能会导致链式反应其后一个结点的需要从一字节扩容至五字节最坏情况下第一个结点的扩容会导致整个表中的后续所有结点的字段扩容虽然这个内存重分配的操作依然只会发生一次但代码中的时间复杂度是级别因为链式扩容只能一步一步的计算但这种情况的概率十分的小一般情况下链式扩容能连锁反映五六次就很不幸了之所以说这是一个蛋疼问题是因为这样的坏场景下其实时间复杂度并不高依次计算每个新的空间占用也就是总体占用计算出来后只执行一次内存重分配与对应的操作就可以了快表这个结构是在版本后新加的之前的版本是即用于数据类型中它是一种以为结点的双端链表结构宏观上是一个链表微观上链表中的每个结点都是一个结构如下是源码中相关的结构这里定义了个结构体宏观上是一个链表这个结构描述的就是链表中的结点它通过字段持有底层的简单来讲它描述了一个实例是一段连续的内存用算法压缩后就可以包装成一个结构是否压缩中的每个实例是一个可配置项若这个配置项是开启的那么字段指向的就不是一个实例而是一个压缩后的实例在尾部增加的一个书签它只有在大量节点的多余内存使用量可以忽略不计的情况且确实需要分批迭代它们才会被使用当不使用它们时它们不会增加任何内存开销这就是一个双链表的定义分别指向头尾指针代表链表中的结点指的是整个中的所有中的的数目字段影响着每个链表结点中的最大占用空间影响着是否要对每个以算法进行进一步压缩以更节省内存空间是一个迭代器是对中的概念的封装作为一个封装良好的数据结构不希望使用者感知到其内部的实现所以需要把的概念重新包装一下内存布局图的内存布局图如下所示更多额外信息下面是有关的更多额外信息的值影响着每个链表结点中的长度当数值为负数时代表以字节数限制单个的最大长度具体为不超过不超过不超过不超过不超过当数值为正数时代表以数目限制单个的长度值即为数目由于该字段仅占位所以以数目限制的容量时最大值为个的值影响着字段指向的是原生的还是经过压缩包装后的表示不压缩字段直接指向表示的链表头尾结点不压缩其余结点的字段指向的是经过压缩后的表示的链表头两个与末两个结点不压缩其余结点的字段指向的是经过压缩后的以此类推最大值为字段以指示本链表结点所持有的是否经过了压缩代表未压缩持有的是原生的代表压缩过字段指示的是每个链表结点所持有的数据类型是什么默认的实现是对应的该字段的值是目前没有提供其它实现所以实际上该字段的值恒为字段指示的是当前结点所持有的是否经过了解压如果该字段为即代表之前被解压过且需要在下一次操作时重新压缩的具体实现代码篇幅很长这里就不贴代码片断了从内存布局上也能看出来由于每个结点持有的是有上限长度的所以在与操作时要考虑的分支情况比较多有自己的优点也有缺点对于使用者来说其使用体验类似于线性数据结构作为最传统的双链表结点通过指针持有数据指针字段会耗费大量内存解决了耗费内存这个问题但引入了新的问题每次写操作整个的内存都需要重分配在两者之间做了一个平衡并且使用者可以通过自定义根据实际业务情况经验主义调参字典哈希表本质上就是哈希表这个在很多语言中都有对于开发人员人员来说比较熟悉这里就简单介绍下数据结构哈希表结构定义哈希表数组哈希表大小哈希表大小掩码用于计算索引值总是等于该哈希表已有节点的数量哈希表是由数组组成中每个元素都是指向结构结构定义如下键值指向下一个哈希表节点形成链表用来保存键属性用来保存值值可以是一个指针也可以是整数也可以是整数注意这里还有一个指向下一个哈希表节点的指针我们知道哈希表最大的问题是存在哈希冲突如何解决哈希冲突有开放地址法和链地址法这里采用的便是链地址法通过这个指针可以将多个哈希值相同的键值对连接在一起用来解决哈希冲突一些要点哈希算法计算哈希值和索引值方法如下使用字典设置的哈希函数计算键的哈希值使用哈希表的属性和第一步得到的哈希值计算索引值解决哈希冲突这个问题上面我们介绍了方法是链地址法通过字典里面的指针指向下一个具有相同索引值的哈希表节点扩容和收缩当哈希表保存的键值对太多或者太少时就要通过重新散列来对哈希表进行相应的扩展或者收缩具体步骤如果执行扩展操作会基于原哈希表创建一个大小等于的哈希表也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表相反如果执行的是收缩操作每次收缩是根据已使用空间缩小一倍创建一个新的哈希表重新利用上面的哈希算法计算索引值然后将键值对放到新的哈希表位置上所有键值对都迁徙完毕后释放原哈希表的内存空间触发扩容的条件服务器目前没有执行命令或者命令并且负载因子大于等于服务器目前正在执行命令或者命令并且负载因子大于等于负载因子哈希表已保存节点数量哈希表大小渐近式什么叫渐进式也就是说扩容和收缩操作不是一次性集中式完成的而是分多次渐进式完成的如果保存在中的键值对只有几个几十个那么操作可以瞬间完成但是如果键值对有几百万几千万甚至几亿那么要一次性的进行势必会造成一段时间内不能进行别的操作所以采用渐进式这样在进行渐进式期间字典的删除查找更新等操作可能会在两个哈希表上进行第一个哈希表没有找到就会去第二个哈希表上进行查找但是进行增加操作一定是在新的哈希表上进行的整数集整数集合是集合类型的底层实现之一当一个集合只包含整数值元素并且这个集合的元素数量不多时就会使用整数集合作为集合键的底层实现结构首先看源码结构表示编码方式的取值有三个代表其中存储的整数的个数指向实际存储数值的连续内存区域就是一个数组整数集合的每个元素都是数组的一个数组项各个项在数组中按值得大小从小到大有序排序且数组中不包含任何重复项虽然结构将属性声明为类型的数组但实际上数组并不保存任何类型的值数组的真正类型取决于属性的值内存布局图其内存布局如下图所示我们可以看到数组里面每个元素的数据类型是由来决定的那么如果原来的数据类型是当我们再插入一个类型的数据时怎么办呢这就是下面要说的的升级整数集合的升级当在一个类型的整数集合中插入一个类型的值整个集合的所有元素都会转换成类型整个过程有三步根据新元素的类型比如扩展整数集合底层数组的空间大小并为新元素分配空间将底层数组现有的所有元素都转换成与新元素相同的类型并将类型转换后的元素放置到正确的位上而且在放置元素的过程中需要继续维持底层数组的有序性质不变最后改变的值那么如果我们删除掉刚加入的类型时会不会做一个降级操作呢不会主要还是减少开销的权衡跳表跳表性能堪比红黑树深度分析跳跃表结构在中的运用场景只有一个那就是作为有序列表的使用跳跃表的性能可以保证在查找删除添加等操作的时候在对数期望时间内完成这个性能是可以和平衡树来相比较的而且在实现方面比平衡树要优雅这就是跳跃表的长处跳跃表的缺点就是需要的存储空间比较大属于利用空间来换取时间的数据结构什么是跳跃表跳跃表要解决什么问题呢如果你一上来就去看它的实现你很难理解设计的本质所以先要看它的设计要解决什么问题对于于一个单链表来讲即便链表中存储的数据是有序的如果我们要想在其中查找某个数据也只能从头到尾遍历链表这样查找效率就会很低时间复杂度会很高是比如查找需要次查找如果我们增加如下两级索引那么它搜索次数就变成了次跳跃表的设计跳跃表并没有在单独的类比如中定义而是其定义在中如下其内存布局如下图的核心设计要点头节点不持有任何数据且其的长度为每个结点字段持有数据是类型字段其标示着结点的得分结点之间凭借得分来判断先后顺序跳跃表中的结点按结点的得分升序排列指针这是原版跳跃表中所没有的该指针指向结点的前一个紧邻结点字段用以记录所有结点除过头节点外每个结点中最多持有个结构实际数量在结点创建时按幂次定律随机生成不超过每个中有两个字段字段指向比自己得分高的某个结点不一定是紧邻的并且若当前实例在中的索引为则其字段指向的结点其字段的容量至少是这也是上图中为什么指针总是画的水平的原因字段代表字段指向的结点距离当前结点的距离紧邻的两个结点之间的距离定义为为什么不用平衡树或者哈希表为什么不是平衡树先看下作者的回答简而言之就是实现简单且达到了类似效果与平衡树哈希表的比较和各种平衡树如红黑树等的元素是有序排列的而哈希表不是有序的因此在哈希表上只能做单个的查找不适宜做范围查找所谓范围查找指的是查找那些大小在指定的两个值之间的所有节点在做范围查找的时候平衡树比操作要复杂在平衡树上我们找到指定范围的小值之后还需要以中序遍历的顺序继续寻找其它不超过大值的节点如果不对平衡树进行一定的改造这里的中序遍历并不容易实现而在上进行范围查找就非常简单只需要在找到小值之后对第层链表进行若干步的遍历就可以实现平衡树的插入和删除操作可能引发子树的调整逻辑复杂而的插入和删除只需要修改相邻节点的指针操作简单又快速从内存占用上来说比平衡树更灵活一些一般来说平衡树每个节点包含个指针分别指向左右子树而每个节点包含的指针数目平均为具体取决于参数的大小如果像里的实现一样取那么平均每个节点包含个指针比平衡树更有优势查找单个和平衡树的时间复杂度都为大体相当而哈希表在保持较低的哈希值冲突概率的前提下查找时间复杂度接近性能更高一些所以我们平常使用的各种或结构大都是基于哈希表实现的从算法实现难度上来比较比平衡树要简单得多参考文章源码还参考了',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-06-07 20:51:19',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">凌霄的博客</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/kongxiaoran/image-repo/blog20241226231130275.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://cdn.jsdelivr.net/gh/kongxiaoran/image-repo/blog20241226231130275.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/kongxiaoran/image-repo/blog20241226231143327.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://cdn.jsdelivr.net/gh/kongxiaoran/image-repo/blog20241226231143327.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Argon2/" style="font-size: 1.05rem;">Argon2<sup>1</sup></a><a href="/tags/HBase/" style="font-size: 1.05rem;">HBase<sup>1</sup></a><a href="/tags/HDFS/" style="font-size: 1.05rem;">HDFS<sup>2</sup></a><a href="/tags/Hadoop/" style="font-size: 1.05rem;">Hadoop<sup>1</sup></a><a href="/tags/Hive/" style="font-size: 1.05rem;">Hive<sup>1</sup></a><a href="/tags/Java/" style="font-size: 1.05rem;">Java<sup>5</sup></a><a href="/tags/Kubernetes/" style="font-size: 1.05rem;">Kubernetes<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>4</sup></a><a href="/tags/MinIO/" style="font-size: 1.05rem;">MinIO<sup>1</sup></a><a href="/tags/NAT/" style="font-size: 1.05rem;">NAT<sup>1</sup></a><a href="/tags/S3%E5%85%BC%E5%AE%B9/" style="font-size: 1.05rem;">S3兼容<sup>1</sup></a><a href="/tags/Spark/" style="font-size: 1.05rem;">Spark<sup>2</sup></a><a href="/tags/Spring/" style="font-size: 1.05rem;">Spring<sup>2</sup></a><a href="/tags/YARN/" style="font-size: 1.05rem;">YARN<sup>1</sup></a><a href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" style="font-size: 1.05rem;">云原生<sup>1</sup></a><a href="/tags/%E5%86%85%E5%AD%98%E8%AE%A1%E7%AE%97/" style="font-size: 1.05rem;">内存计算<sup>1</sup></a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%84%E7%90%86/" style="font-size: 1.05rem;">分布式处理<sup>1</sup></a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/" style="font-size: 1.05rem;">分布式存储<sup>2</sup></a><a href="/tags/%E5%93%88%E5%B8%8C/" style="font-size: 1.05rem;">哈希<sup>1</sup></a><a href="/tags/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">哈希算法<sup>1</sup></a><a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 1.05rem;">大数据<sup>1</sup></a><a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 1.05rem;">安全<sup>2</sup></a><a href="/tags/%E5%AF%86%E7%A0%81%E5%93%88%E5%B8%8C/" style="font-size: 1.05rem;">密码哈希<sup>1</sup></a><a href="/tags/%E5%AF%86%E7%A0%81%E5%AD%98%E5%82%A8/" style="font-size: 1.05rem;">密码存储<sup>1</sup></a><a href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" style="font-size: 1.05rem;">密码学<sup>1</sup></a><a href="/tags/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/" style="font-size: 1.05rem;">对象存储<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 1.05rem;">并发<sup>2</sup></a><a href="/tags/%E7%B3%BB%E7%BB%9F/" style="font-size: 1.05rem;">系统<sup>2</sup></a><a href="/tags/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/" style="font-size: 1.05rem;">系统安全<sup>2</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">网络<sup>4</sup></a><a href="/tags/%E9%98%B2%E7%81%AB%E5%A2%99/" style="font-size: 1.05rem;">防火墙<sup>2</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/06/"><span class="card-archive-list-date">六月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">25</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url">后端</a></span><span class="article-meta tags"></span></div></div><h1 class="post-title" itemprop="name headline">Redis 底层数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-06-06T16:00:00.000Z" title="发表于 2025-06-07 00:00:00">2025-06-07</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-06-07T12:51:19.691Z" title="更新于 2025-06-07 20:51:19">2025-06-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="Redis 底层数据结构"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为杭州"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>杭州</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/20250607204045262.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2025/06/07/Redis%20%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><header><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url">后端</a><h1 id="CrawlerTitle" itemprop="name headline">Redis 底层数据结构</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">XR</span><time itemprop="dateCreated datePublished" datetime="2025-06-06T16:00:00.000Z" title="发表于 2025-06-07 00:00:00">2025-06-07</time><time itemprop="dateCreated datePublished" datetime="2025-06-07T12:51:19.691Z" title="更新于 2025-06-07 20:51:19">2025-06-07</time></header><h1 id="Redis-底层数据结构"><a href="#Redis-底层数据结构" class="headerlink" title="Redis 底层数据结构"></a>Redis 底层数据结构</h1><p>原文拷贝：<a target="_blank" rel="noopener" href="https://pdai.tech/md/db/nosql-redis/db-redis-x-redis-ds.html">https://pdai.tech/md/db/nosql-redis/db-redis-x-redis-ds.html</a></p>
<h2 id="1-底层数据结构引入"><a href="#1-底层数据结构引入" class="headerlink" title="1. 底层数据结构引入"></a>1. 底层数据结构引入</h2><p>在对对象机制（redisObject）有了初步认识之后，我们便可以继续理解如下的底层数据结构部分：</p>
<ul>
<li>简单动态字符串 - sds</li>
<li>压缩列表 - ZipList</li>
<li>快表 - QuickList</li>
<li>字典&#x2F;哈希表 - Dict</li>
<li>整数集 - IntSet</li>
<li>跳表 - ZSkipList</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/1683186163371-8b104d7d-6d48-48be-b36f-00239b94f2c6-20250605104506666.png" alt="img"></h2><h2 id="2-简单动态字符串-sds"><a href="#2-简单动态字符串-sds" class="headerlink" title="2. 简单动态字符串 - sds"></a>2. 简单动态字符串 - sds</h2><p>Redis 是用 C 语言写的，但是对于Redis的字符串，却不是 C 语言中的字符串（即以空字符’\0’结尾的字符数组），它是自己构建了一种名为 <strong>简单动态字符串（simple dynamic string,SDS</strong>）的抽象类型，并将 SDS 作为 Redis的默认字符串表示。</p>
<h3 id="2-1-SDS-定义"><a href="#2-1-SDS-定义" class="headerlink" title="2.1. SDS 定义"></a>2.1. SDS 定义</h3><p>这是一种用于存储二进制数据的一种结构, 具有动态扩容的特点. 其实现位于src&#x2F;sds.h与src&#x2F;sds.c中。</p>
<ul>
<li><strong>SDS的总体概览</strong>如下图:</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/1683186200481-7f03df1c-74c9-40d7-98bb-dcd47b24fef0.png" alt="img"></p>
<p>其中sdshdr是头部, buf是真实存储用户数据的地方. 另外注意, 从命名上能看出来, 这个数据结构除了能存储二进制数据, 显然是用于设计作为字符串使用的, 所以在buf中, 用户数据后总跟着一个\0. 即图中 “数据” + “\0” 是为所谓的buf。</p>
<ul>
<li>如下是<strong>6.0源码中sds相关的结构</strong>：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/1683186307934-1a2abbea-4cc0-4975-bbce-43e33ab4cfe6-20250605104457766.png" alt="img"></p>
<p>通过上图我们可以看到，SDS有五种不同的头部. 其中sdshdr5实际并未使用到. 所以实际上有四种不同的头部, 分别如下:</p>
<p>其中：</p>
<ul>
<li><ul>
<li>len 保存了SDS保存字符串的长度</li>
<li>buf[] 数组用来保存字符串的每个元素</li>
<li>alloc分别以uint8, uint16, uint32, uint64表示整个SDS, 除过头部与末尾的\0, 剩余的字节数.</li>
<li>flags 始终为一字节, 以低三位标示着头部的类型, 高5位未使用.</li>
</ul>
</li>
</ul>
<h3 id="2-2-为什么使用SDS"><a href="#2-2-为什么使用SDS" class="headerlink" title="2.2. 为什么使用SDS"></a>2.2. 为什么使用SDS</h3><p><strong>为什么不使用C语言字符串实现，而是使用 SDS呢</strong>？这样实现有什么好处？</p>
<ul>
<li><strong>常数复杂度获取字符串长度</strong></li>
</ul>
<p>由于 len 属性的存在，我们获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O(1)。而对于 C 语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。通过 strlen key 命令可以获取 key 的字符串长度。</p>
<ul>
<li><strong>杜绝缓冲区溢出</strong></li>
</ul>
<p>我们知道在 C 语言中使用 strcat 函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。而对于 SDS 数据类型，在进行字符修改的时候，<strong>会首先根据记录的 len 属性检查内存空间是否满足需求</strong>，如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出。</p>
<ul>
<li><strong>减少修改字符串的内存重新分配次数</strong></li>
</ul>
<p>C语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。</p>
<p>而对于SDS，由于len属性和alloc属性的存在，对于修改字符串SDS实现了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种策略：</p>
<p>1、空间预分配：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。</p>
<p>2、惰性空间释放：对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 alloc 属性将这些字节的数量记录下来，等待后续使用。（当然SDS也提供了相应的API，当我们有需要时，也可以手动释放这些未使用的空间。）</p>
<ul>
<li><strong>二进制安全</strong></li>
</ul>
<p>因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而所有 SDS 的API 都是以处理二进制的方式来处理 buf 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束。</p>
<ul>
<li><strong>兼容部分 C 字符串函数</strong></li>
</ul>
<p>虽然 SDS 是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库&lt;string.h&gt; 中的一部分函数。</p>
<h3 id="2-3-空间预分配补进一步理解"><a href="#2-3-空间预分配补进一步理解" class="headerlink" title="2.3. 空间预分配补进一步理解"></a>2.3. 空间预分配补进一步理解</h3><p>当执行追加操作时，比如现在给key&#x3D;‘Hello World’的字符串后追加‘ again!’则这时的len&#x3D;18，free由0变成了18，此时的buf&#x3D;’Hello World again!\0………………..’(.表示空格)，也就是buf的内存空间是18+18+1&#x3D;37个字节，其中‘\0’占1个字节redis给字符串多分配了18个字节的预分配空间，所以下次还有append追加的时候，如果预分配空间足够，就无须在进行空间分配了。在当前版本中，当新字符串的长度小于1M时，redis会分配他们所需大小一倍的空间，当大于1M的时候，就为他们额外多分配1M的空间。</p>
<p>思考：<strong>这种分配策略会浪费内存资源吗</strong>？</p>
<p>答：执行过APPEND 命令的字符串会带有额外的预分配空间，这些预分配空间不会被释放，除非该字符串所对应的键被删除，或者等到关闭Redis 之后，再次启动时重新载入的字符串对象将不会有预分配空间。因为执行APPEND 命令的字符串键数量通常并不多，占用内存的体积通常也不大，所以这一般并不算什么问题。另一方面，如果执行APPEND 操作的键很多，而字符串的体积又很大的话，那可能就需要修改Redis 服务器，让它定时释放一些字符串键的预分配空间，从而更有效地使用内存。</p>
<h3 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4. 小结"></a>2.4. 小结</h3><p>redis的字符串表示为sds，而不是C字符串（以\0结尾的char*）， 它是Redis 底层所使用的字符串表示，它被用在几乎所有的Redis 模块中。可以看如下对比：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/1683186398426-e49e97b8-1a09-4af9-b24e-69d9427e0a86-20250605104730696.png" alt="img"></p>
<p>一般来说，SDS 除了保存数据库中的字符串值以外，SDS 还可以作为缓冲区（buffer）：包括 AOF 模块中的AOF缓冲区以及客户端状态中的输入缓冲区。</p>
<h2 id="3-压缩列表-ZipList"><a href="#3-压缩列表-ZipList" class="headerlink" title="3. 压缩列表 - ZipList"></a>3. 压缩列表 - ZipList</h2><p>ziplist是为了提高存储效率而设计的一种特殊编码的双向链表。它可以存储字符串或者整数，存储整数时是采用整数的二进制而不是字符串形式存储。它能在O(1)的时间复杂度下完成list两端的push和pop操作。但是因为每次操作都需要重新分配ziplist的内存，所以实际复杂度和ziplist的内存使用量相关。</p>
<h3 id="3-1-ziplist结构"><a href="#3-1-ziplist结构" class="headerlink" title="3.1. ziplist结构"></a>3.1. ziplist结构</h3><p>先看下6.0中对应的源码和介绍</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/1683186463010-998f824b-0c42-4671-975c-e4ecd0303661.png" alt="img"></p>
<p>整个ziplist在内存中的存储格式如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/1683186477713-f4b4e9f1-70c0-41aa-af35-d8cdd8872970-20250605104738622.png" alt="img"></p>
<ul>
<li>zlbytes字段的类型是uint32_t, 这个字段中存储的是整个ziplist所占用的内存的字节数</li>
<li>zltail字段的类型是uint32_t, 它指的是ziplist中最后一个entry的偏移量. 用于快速定位最后一个entry, 以快速完成pop等操作</li>
<li>zllen字段的类型是uint16_t, 它指的是整个ziplit中entry的数量. 这个值只占2bytes（16位）: 如果ziplist中entry的数目小于65535(2的16次方), 那么该字段中存储的就是实际entry的值. 若等于或超过65535, 那么该字段的值固定为65535, 但实际数量需要一个个entry的去遍历所有entry才能得到.</li>
<li>zlend是一个终止字节, 其值为全F, 即0xff. ziplist保证任何情况下, 一个entry的首字节都不会是255</li>
</ul>
<h3 id="3-2-Entry结构"><a href="#3-2-Entry结构" class="headerlink" title="3.2. Entry结构"></a>3.2. Entry结构</h3><p>那么entry是什么结构呢？</p>
<p><strong>先看下源码中相关介绍</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/1683186554347-d3b74eed-8e4b-42fd-9f2d-0cc62bd39af1-20250605104447715.png" alt="img"></p>
<p><strong>第一种情况</strong>：一般结构 <prevlen> <encoding> <entry-data></p>
<p>prevlen：前一个entry的大小，编码方式见下文；</p>
<p>encoding：不同的情况下值不同，用于表示当前entry的类型和长度；</p>
<p>entry-data：真是用于存储entry表示的数据；</p>
<p><strong>第二种情况</strong>：在entry中存储的是int类型时，encoding和entry-data会合并在encoding中表示，此时没有entry-data字段；</p>
<p>redis中，在存储数据时，会先尝试将string转换成int存储，节省空间；</p>
<p>此时entry结构：<prevlen> <encoding></p>
<ul>
<li><strong>prevlen编码</strong></li>
</ul>
<p>当前一个元素长度小于254（255用于zlend）的时候，prevlen长度为1个字节，值即为前一个entry的长度，如果长度大于等于254的时候，prevlen用5个字节表示，第一字节设置为254，后面4个字节存储一个小端的无符号整型，表示前一个entry的长度；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;prevlen from 0 to 253&gt; &lt;encoding&gt; &lt;entry&gt;      //长度小于254结构 0xFE &lt;4 bytes unsigned little endian prevlen&gt; &lt;encoding&gt; &lt;entry&gt;   //长度大于等于254</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>encoding编码</strong></li>
</ul>
<p>encoding的长度和值根据保存的是int还是string，还有数据的长度而定；</p>
<p>前两位用来表示类型，当为“11”时，表示entry存储的是int类型，其它表示存储的是string；</p>
<p><strong>存储string时</strong>：</p>
<p>|00pppppp| ：此时encoding长度为1个字节，该字节的后六位表示entry中存储的string长度，因为是6位，所以entry中存储的string长度不能超过63；</p>
<p>|01pppppp|qqqqqqqq| 此时encoding长度为两个字节；此时encoding的后14位用来存储string长度，长度不能超过16383；</p>
<p>|10000000|qqqqqqqq|rrrrrrrr|ssssssss|ttttttt| 此时encoding长度为5个字节，后面的4个字节用来表示encoding中存储的字符串长度，长度不能超过2^32 - 1;</p>
<p><strong>存储int时</strong>：</p>
<p>|11000000| encoding为3个字节，后2个字节表示一个int16；</p>
<p>|11010000| encoding为5个字节，后4个字节表示一个int32;</p>
<p>|11100000| encoding 为9个字节，后8字节表示一个int64;</p>
<p>|11110000| encoding为4个字节，后3个字节表示一个有符号整型；</p>
<p>|11111110| encoding为2字节，后1个字节表示一个有符号整型；</p>
<p>|1111xxxx| encoding长度就只有1个字节，xxxx表示一个0 - 12的整数值；</p>
<p>|11111111| 还记得zlend么？</p>
<ul>
<li><strong>源码中数据结构支撑</strong></li>
</ul>
<p>你可以看到为了操作上的简易实际还增加了几个属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/* We use this function to receive information about a ziplist entry. * Note that this is not how the data is actually encoded, is just what we * get filled by a function in order to operate more easily. */ typedef struct zlentry &#123;    unsigned int prevrawlensize; /* Bytes used to encode the previous entry len*/    unsigned int prevrawlen;     /* Previous entry len. */    unsigned int lensize;        /* Bytes used to encode this entry type/len.                                    For example strings have a 1, 2 or 5 bytes                                    header. Integers always use a single byte.*/    unsigned int len;            /* Bytes used to represent the actual entry.                                    For strings this is just the string length                                    while for integers it is 1, 2, 3, 4, 8 or                                    0 (for 4 bit immediate) depending on the                                    number range. */    unsigned int headersize;     /* prevrawlensize + lensize. */    unsigned char encoding;      /* Set to ZIP_STR_* or ZIP_INT_* depending on                                    the entry encoding. However for 4 bits                                    immediate integers this can assume a range                                    of values and must be range-checked. */    unsigned char *p;            /* Pointer to the very start of the entry, that                                    is, this points to prev-entry-len field. */ &#125; zlentry;</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>prevrawlensize表示 previous_entry_length字段的长度</li>
<li>prevrawlen表示 previous_entry_length字段存储的内容</li>
<li>lensize表示 encoding字段的长度</li>
<li>len表示数据内容长度</li>
<li>headersize 表示当前元素的首部长度，即previous_entry_length字段长度与encoding字段长度之和</li>
<li>encoding表示数据类型</li>
<li>p表示当前元素首地址</li>
</ul>
</li>
</ul>
<h3 id="3-3-为什么ZipList特别省内存"><a href="#3-3-为什么ZipList特别省内存" class="headerlink" title="3.3. 为什么ZipList特别省内存"></a>3.3. 为什么ZipList特别省内存</h3><p>所以只有理解上面的Entry结构，我们才会真正理解ZipList为什么是特别节省内存的数据结构。</p>
<ul>
<li>ziplist节省内存是相对于普通的list来说的，如果是普通的数组，那么它每个元素占用的内存是一样的且取决于最大的那个元素（很明显它是需要预留空间的）；</li>
<li>所以ziplist在设计时就很容易想到要尽量让每个元素按照实际的内容大小存储，<strong>所以增加encoding字段</strong>，针对不同的encoding来细化存储大小；</li>
<li>这时候还需要解决的一个问题是遍历元素时如何定位下一个元素呢？在普通数组中每个元素定长，所以不需要考虑这个问题；但是ziplist中每个data占据的内存不一样，所以为了解决遍历，需要增加记录上一个元素的length，<strong>所以增加了prelen字段</strong>。</li>
</ul>
<p><strong>为什么我们去研究ziplist特别节省内存的数据结构</strong>？ 在实际应用中，大量存储字符串的优化是需要你对底层的数据结构有一定的理解的，而ziplist在场景优化的时候也被考虑采用的首选。</p>
<h3 id="3-4-ziplist的缺点"><a href="#3-4-ziplist的缺点" class="headerlink" title="3.4. ziplist的缺点"></a>3.4. ziplist的缺点</h3><p>最后我们再看看它的一些缺点：</p>
<ul>
<li>ziplist也不预留内存空间, 并且在移除结点后, 也是立即缩容, 这代表每次写操作都会进行内存分配操作.</li>
<li>结点如果扩容, 导致结点占用的内存增长, 并且超过254字节的话, 可能会导致链式反应: 其后一个结点的entry.prevlen需要从一字节扩容至五字节. <strong>最坏情况下, 第一个结点的扩容, 会导致整个ziplist表中的后续所有结点的entry.prevlen字段扩容</strong>. 虽然这个内存重分配的操作依然只会发生一次, 但代码中的时间复杂度是o(N)级别, 因为链式扩容只能一步一步的计算. 但这种情况的概率十分的小, 一般情况下链式扩容能连锁反映五六次就很不幸了. 之所以说这是一个蛋疼问题, 是因为, 这样的坏场景下, 其实时间复杂度并不高: 依次计算每个entry新的空间占用, 也就是o(N), 总体占用计算出来后, 只执行一次内存重分配, 与对应的memmove操作, 就可以了.</li>
</ul>
<h2 id="4-快表-QuickList"><a href="#4-快表-QuickList" class="headerlink" title="4. 快表 - QuickList"></a>4. 快表 - QuickList</h2><p>quicklist这个结构是Redis在3.2版本后新加的, 之前的版本是list(即linkedlist)， 用于String数据类型中。</p>
<p>它是一种以ziplist为结点的双端链表结构. 宏观上, quicklist是一个链表, 微观上, 链表中的每个结点都是一个ziplist。</p>
<h3 id="4-1-quicklist结构"><a href="#4-1-quicklist结构" class="headerlink" title="4.1. quicklist结构"></a>4.1. quicklist结构</h3><ul>
<li>如下是<strong>6.0源码中quicklist相关的结构</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Node, quicklist, and Iterator are the only data structures used currently. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* quicklistNode is a 32 byte struct describing a ziplist for a quicklist.</span></span><br><span class="line"><span class="comment"> * We use bit fields keep the quicklistNode at 32 bytes.</span></span><br><span class="line"><span class="comment"> * count: 16 bits, max 65536 (max zl bytes is 65k, so max count actually &lt; 32k).</span></span><br><span class="line"><span class="comment"> * encoding: 2 bits, RAW=1, LZF=2.</span></span><br><span class="line"><span class="comment"> * container: 2 bits, NONE=1, ZIPLIST=2.</span></span><br><span class="line"><span class="comment"> * recompress: 1 bit, bool, true if node is temporarry decompressed for usage.</span></span><br><span class="line"><span class="comment"> * attempted_compress: 1 bit, boolean, used for verifying during testing.</span></span><br><span class="line"><span class="comment"> * extra: 10 bits, free for future use; pads out the remainder of 32 bits */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;             <span class="comment">/* ziplist size in bytes */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count : <span class="number">16</span>;     <span class="comment">/* count of items in ziplist */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> encoding : <span class="number">2</span>;   <span class="comment">/* RAW==1 or LZF==2 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> container : <span class="number">2</span>;  <span class="comment">/* NONE==1 or ZIPLIST==2 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> recompress : <span class="number">1</span>; <span class="comment">/* was this node previous compressed? */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* node can&#x27;t compress; too small */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> extra : <span class="number">10</span>; <span class="comment">/* more bits to steal for future usage */</span></span><br><span class="line">&#125; quicklistNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* quicklistLZF is a 4+N byte struct holding &#x27;sz&#x27; followed by &#x27;compressed&#x27;.</span></span><br><span class="line"><span class="comment"> * &#x27;sz&#x27; is byte length of &#x27;compressed&#x27; field.</span></span><br><span class="line"><span class="comment"> * &#x27;compressed&#x27; is LZF data with total (compressed) length &#x27;sz&#x27;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> uncompressed length is stored in quicklistNode-&gt;sz.</span></span><br><span class="line"><span class="comment"> * When quicklistNode-&gt;zl is compressed, node-&gt;zl points to a quicklistLZF */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistLZF</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz; <span class="comment">/* LZF size in bytes*/</span></span><br><span class="line">    <span class="type">char</span> compressed[];</span><br><span class="line">&#125; quicklistLZF;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bookmarks are padded with realloc at the end of of the quicklist struct.</span></span><br><span class="line"><span class="comment"> * They should only be used for very big lists if thousands of nodes were the</span></span><br><span class="line"><span class="comment"> * excess memory usage is negligible, and there&#x27;s a real need to iterate on them</span></span><br><span class="line"><span class="comment"> * in portions.</span></span><br><span class="line"><span class="comment"> * When not used, they don&#x27;t add any memory overhead, but when used and then</span></span><br><span class="line"><span class="comment"> * deleted, some overhead remains (to avoid resonance).</span></span><br><span class="line"><span class="comment"> * The number of bookmarks used should be kept to minimum since it also adds</span></span><br><span class="line"><span class="comment"> * overhead on node deletion (searching for a bookmark to update). */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistBookmark</span> &#123;</span></span><br><span class="line">    quicklistNode *node;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">&#125; quicklistBookmark;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* quicklist is a 40 byte struct (on 64-bit systems) describing a quicklist.</span></span><br><span class="line"><span class="comment"> * &#x27;count&#x27; is the number of total entries.</span></span><br><span class="line"><span class="comment"> * &#x27;len&#x27; is the number of quicklist nodes.</span></span><br><span class="line"><span class="comment"> * &#x27;compress&#x27; is: -1 if compression disabled, otherwise it&#x27;s the number</span></span><br><span class="line"><span class="comment"> *                of quicklistNodes to leave uncompressed at ends of quicklist.</span></span><br><span class="line"><span class="comment"> * &#x27;fill&#x27; is the user-requested (or default) fill factor.</span></span><br><span class="line"><span class="comment"> * &#x27;bookmakrs are an optional feature that is used by realloc this struct,</span></span><br><span class="line"><span class="comment"> *      so that they don&#x27;t consume memory when not used. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count;        <span class="comment">/* total count of all entries in all ziplists */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;          <span class="comment">/* number of quicklistNodes */</span></span><br><span class="line">    <span class="type">int</span> fill : QL_FILL_BITS;              <span class="comment">/* fill factor for individual nodes */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> compress : QL_COMP_BITS; <span class="comment">/* depth of end nodes not to compress;0=off */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bookmark_count: QL_BM_BITS;</span><br><span class="line">    quicklistBookmark bookmarks[];</span><br><span class="line">&#125; quicklist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistIter</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> quicklist *quicklist;</span><br><span class="line">    quicklistNode *current;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zi;</span><br><span class="line">    <span class="type">long</span> offset; <span class="comment">/* offset in current ziplist */</span></span><br><span class="line">    <span class="type">int</span> direction;</span><br><span class="line">&#125; quicklistIter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistEntry</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> quicklist *quicklist;</span><br><span class="line">    quicklistNode *node;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zi;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *value;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> longval;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;</span><br><span class="line">    <span class="type">int</span> offset;</span><br><span class="line">&#125; quicklistEntry;</span><br></pre></td></tr></table></figure>



<p>这里定义了6个结构体:</p>
<ul>
<li>quicklistNode, 宏观上, quicklist是一个链表, 这个结构描述的就是链表中的结点. 它通过zl字段持有底层的ziplist. 简单来讲, 它描述了一个ziplist实例</li>
<li>quicklistLZF, ziplist是一段连续的内存, 用LZ4算法压缩后, 就可以包装成一个quicklistLZF结构. 是否压缩quicklist中的每个ziplist实例是一个可配置项. 若这个配置项是开启的, 那么quicklistNode.zl字段指向的就不是一个ziplist实例, 而是一个压缩后的quicklistLZF实例</li>
<li>quicklistBookmark, 在quicklist尾部增加的一个书签，它只有在大量节点的多余内存使用量可以忽略不计的情况且确实需要分批迭代它们，才会被使用。当不使用它们时，它们不会增加任何内存开销。</li>
<li>quicklist. 这就是一个双链表的定义. head, tail分别指向头尾指针. len代表链表中的结点. count指的是整个quicklist中的所有ziplist中的entry的数目. fill字段影响着每个链表结点中ziplist的最大占用空间, compress影响着是否要对每个ziplist以LZ4算法进行进一步压缩以更节省内存空间.</li>
<li>quicklistIter是一个迭代器</li>
<li>quicklistEntry是对ziplist中的entry概念的封装. quicklist作为一个封装良好的数据结构, 不希望使用者感知到其内部的实现, 所以需要把ziplist.entry的概念重新包装一下.</li>
</ul>
<h3 id="4-2-quicklist内存布局图"><a href="#4-2-quicklist内存布局图" class="headerlink" title="4.2. quicklist内存布局图"></a>4.2. quicklist内存布局图</h3><p>quicklist的内存布局图如下所示:</p>
<h3 id="4-3-quicklist更多额外信息"><a href="#4-3-quicklist更多额外信息" class="headerlink" title="4.3. quicklist更多额外信息"></a>4.3. quicklist更多额外信息</h3><p>下面是有关quicklist的更多额外信息:</p>
<ul>
<li>quicklist.fill的值影响着每个链表结点中, ziplist的长度.</li>
</ul>
<ol>
<li><ol>
<li>当数值为负数时, 代表以字节数限制单个ziplist的最大长度. 具体为:</li>
<li>-1 不超过4kb</li>
<li>-2 不超过 8kb</li>
<li>-3 不超过 16kb</li>
<li>-4 不超过 32kb</li>
<li>-5 不超过 64kb</li>
<li>当数值为正数时, 代表以entry数目限制单个ziplist的长度. 值即为数目. 由于该字段仅占16位, 所以以entry数目限制ziplist的容量时, 最大值为2^15个</li>
</ol>
</li>
</ol>
<ul>
<li>quicklist.compress的值影响着quicklistNode.zl字段指向的是原生的ziplist, 还是经过压缩包装后的quicklistLZF</li>
</ul>
<ol>
<li><ol>
<li>0 表示不压缩, zl字段直接指向ziplist</li>
<li>1 表示quicklist的链表头尾结点不压缩, 其余结点的zl字段指向的是经过压缩后的quicklistLZF</li>
<li>2 表示quicklist的链表头两个, 与末两个结点不压缩, 其余结点的zl字段指向的是经过压缩后的quicklistLZF</li>
<li>以此类推, 最大值为2^16</li>
</ol>
</li>
</ol>
<ul>
<li>quicklistNode.encoding字段, 以指示本链表结点所持有的ziplist是否经过了压缩. 1代表未压缩, 持有的是原生的ziplist, 2代表压缩过</li>
<li>quicklistNode.container字段指示的是每个链表结点所持有的数据类型是什么. 默认的实现是ziplist, 对应的该字段的值是2, 目前Redis没有提供其它实现. 所以实际上, 该字段的值恒为2</li>
<li>quicklistNode.recompress字段指示的是当前结点所持有的ziplist是否经过了解压. 如果该字段为1即代表之前被解压过, 且需要在下一次操作时重新压缩.</li>
</ul>
<p>quicklist的具体实现代码篇幅很长, 这里就不贴代码片断了, 从内存布局上也能看出来, 由于每个结点持有的ziplist是有上限长度的, 所以在与操作时要考虑的分支情况比较多。</p>
<p>quicklist有自己的优点, 也有缺点, 对于使用者来说, 其使用体验类似于线性数据结构, list作为最传统的双链表, 结点通过指针持有数据, 指针字段会耗费大量内存. ziplist解决了耗费内存这个问题. 但引入了新的问题: 每次写操作整个ziplist的内存都需要重分配. quicklist在两者之间做了一个平衡. 并且使用者可以通过自定义quicklist.fill, 根据实际业务情况, 经验主义调参.</p>
<h2 id="5-字典-哈希表-Dict"><a href="#5-字典-哈希表-Dict" class="headerlink" title="5. 字典&#x2F;哈希表 - Dict"></a>5. 字典&#x2F;哈希表 - Dict</h2><p>本质上就是哈希表, 这个在很多语言中都有，对于开发人员人员来说比较熟悉，这里就简单介绍下。</p>
<h3 id="5-1-数据结构"><a href="#5-1-数据结构" class="headerlink" title="5.1. 数据结构"></a>5.1. 数据结构</h3><p><strong>哈希表结构定义</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">    <span class="comment">//哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">//总是等于 size-1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="comment">//该哈希表已有节点的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line"> </span><br><span class="line">&#125;dictht</span><br></pre></td></tr></table></figure>

<p>哈希表是由数组 table 组成，table 中每个元素都是指向 dict.h&#x2F;dictEntry 结构，dictEntry 结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">     <span class="comment">//键</span></span><br><span class="line">     <span class="type">void</span> *key;</span><br><span class="line">     <span class="comment">//值</span></span><br><span class="line">     <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">          <span class="type">void</span> *val;</span><br><span class="line">          uint64_tu64;</span><br><span class="line">          int64_ts64;</span><br><span class="line">     &#125;v;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//指向下一个哈希表节点，形成链表</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;dictEntry</span><br></pre></td></tr></table></figure>



<p>key 用来保存键，val 属性用来保存值，值可以是一个指针，也可以是uint64_t整数，也可以是int64_t整数。</p>
<p>注意这里还有一个指向下一个哈希表节点的指针，我们知道哈希表最大的问题是存在哈希冲突，如何解决哈希冲突，有开放地址法和链地址法。这里采用的便是链地址法，通过next这个指针可以将多个哈希值相同的键值对连接在一起，用来<strong>解决哈希冲突</strong>。</p>
<h3 id="5-2-一些要点"><a href="#5-2-一些要点" class="headerlink" title="5.2. 一些要点"></a>5.2. 一些要点</h3><ul>
<li><strong>哈希算法</strong>：Redis计算哈希值和索引值方法如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1、使用字典设置的哈希函数，计算键 key 的哈希值</span></span><br><span class="line"><span class="built_in">hash</span> = dict-&gt;<span class="built_in">type</span>-&gt;hashFunction(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、使用哈希表的sizemask属性和第一步得到的哈希值，计算索引值</span></span><br><span class="line">index = <span class="built_in">hash</span> &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>解决哈希冲突</strong>：这个问题上面我们介绍了，方法是链地址法。通过字典里面的 *next 指针指向下一个具有相同索引值的哈希表节点。</li>
<li><strong>扩容和收缩</strong>：当哈希表保存的键值对太多或者太少时，就要通过 rerehash(重新散列）来对哈希表进行相应的扩展或者收缩。具体步骤：</li>
</ul>
<p>1、如果执行扩展操作，会基于原哈希表创建一个大小等于 ht[0].used*2n 的哈希表（也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表）。相反如果执行的是收缩操作，每次收缩是根据已使用空间缩小一倍创建一个新的哈希表。</p>
<p>2、重新利用上面的哈希算法，计算索引值，然后将键值对放到新的哈希表位置上。</p>
<p>3、所有键值对都迁徙完毕后，释放原哈希表的内存空间。</p>
<ul>
<li><strong>触发扩容的条件</strong>：</li>
</ul>
<p>1、服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于1。</p>
<p>2、服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于5。</p>
<p>ps：负载因子 &#x3D; 哈希表已保存节点数量 &#x2F; 哈希表大小。</p>
<ul>
<li><strong>渐近式 rehash</strong></li>
</ul>
<p>什么叫渐进式 rehash？也就是说扩容和收缩操作不是一次性、集中式完成的，而是分多次、渐进式完成的。如果保存在Redis中的键值对只有几个几十个，那么 rehash 操作可以瞬间完成，但是如果键值对有几百万，几千万甚至几亿，那么要一次性的进行 rehash，势必会造成Redis一段时间内不能进行别的操作。所以Redis采用渐进式 rehash,这样在进行渐进式rehash期间，字典的删除查找更新等操作可能会在两个哈希表上进行，第一个哈希表没有找到，就会去第二个哈希表上进行查找。但是进行 增加操作，一定是在新的哈希表上进行的。</p>
<h2 id="6-整数集-IntSet"><a href="#6-整数集-IntSet" class="headerlink" title="6. 整数集 - IntSet"></a>6. 整数集 - IntSet</h2><p>整数集合（intset）是集合类型的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis 就会使用整数集合作为集合键的底层实现。</p>
<h3 id="6-1-intset结构"><a href="#6-1-intset结构" class="headerlink" title="6.1. intset结构"></a>6.1. intset结构</h3><p>首先看源码结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>



<p>encoding 表示编码方式，的取值有三个：INTSET_ENC_INT16, INTSET_ENC_INT32, INTSET_ENC_INT64</p>
<p>length 代表其中存储的整数的个数</p>
<p>contents 指向实际存储数值的连续内存区域, 就是一个数组；整数集合的每个元素都是 contents 数组的一个数组项（item），各个项在数组中按值得大小<strong>从小到大有序排序</strong>，且数组中不包含任何重复项。（虽然 intset 结构将 contents 属性声明为 int8_t 类型的数组，但实际上 contents 数组并不保存任何 int8_t 类型的值，contents 数组的真正类型取决于 encoding 属性的值）</p>
<h3 id="6-2-内存布局图"><a href="#6-2-内存布局图" class="headerlink" title="6.2. 内存布局图"></a>6.2. 内存布局图</h3><p>其内存布局如下图所示</p>
<p>我们可以看到，content数组里面每个元素的数据类型是由encoding来决定的，那么如果原来的数据类型是int16, 当我们再插入一个int32类型的数据时怎么办呢？这就是下面要说的intset的升级。</p>
<h3 id="6-3-整数集合的升级"><a href="#6-3-整数集合的升级" class="headerlink" title="6.3. 整数集合的升级"></a>6.3. 整数集合的升级</h3><p>当在一个int16类型的整数集合中插入一个int32类型的值，整个集合的所有元素都会转换成32类型。 整个过程有三步：</p>
<ul>
<li>根据新元素的类型（比如int32），扩展整数集合底层数组的空间大小，并为新元素分配空间。</li>
<li>将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。</li>
<li>最后改变encoding的值，length+1。</li>
</ul>
<p><strong>那么如果我们删除掉刚加入的int32类型时，会不会做一个降级操作呢</strong>？</p>
<p>不会。主要还是减少开销的权衡。</p>
<h2 id="7-跳表-ZSkipList"><a href="#7-跳表-ZSkipList" class="headerlink" title="7. 跳表 - ZSkipList"></a>7. 跳表 - ZSkipList</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/576984787">redis zskiplist跳表，性能堪比红黑树？（深度分析）</a></p>
<p>跳跃表结构在 Redis 中的运用场景只有一个，那就是作为有序列表 (Zset) 的使用。跳跃表的性能可以保证在查找，删除，添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且在实现方面比平衡树要优雅，这就是跳跃表的长处。跳跃表的缺点就是需要的存储空间比较大，属于利用空间来换取时间的数据结构。</p>
<h3 id="7-1-什么是跳跃表"><a href="#7-1-什么是跳跃表" class="headerlink" title="7.1. 什么是跳跃表"></a>7.1. 什么是跳跃表</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/1683188767947-029a8488-19ac-4266-b882-ac1f83760bf7-20250605104436000.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/1683188755238-44e4cadc-ee00-4cb5-80c8-0b8dc991022f.webp" alt="img"></p>
<p>跳跃表要解决什么问题呢？如果你一上来就去看它的实现，你很难理解设计的本质，所以先要看它的设计要解决什么问题。</p>
<p>对于于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。比如查找12，需要7次查找</p>
<p>如果我们增加如下两级索引，那么它搜索次数就变成了3次</p>
<h3 id="7-2-Redis跳跃表的设计"><a href="#7-2-Redis跳跃表的设计" class="headerlink" title="7.2. Redis跳跃表的设计"></a>7.2. Redis跳跃表的设计</h3><p>redis跳跃表并没有在单独的类（比如skplist.c)中定义，而是其定义在server.h中, 如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ZSETs use a specialized version of Skiplists */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>



<p>其内存布局如下图:</p>
<p><strong>zskiplist的核心设计要点</strong></p>
<ul>
<li><p><strong>头节点</strong>不持有任何数据, 且其level[]的长度为32</p>
</li>
<li><p><strong>每个结点</strong></p>
</li>
<li><ul>
<li>ele字段，持有数据，是sds类型</li>
<li>score字段, 其标示着结点的得分, 结点之间凭借得分来判断先后顺序, 跳跃表中的结点按结点的得分升序排列.</li>
<li>backward指针, 这是原版跳跃表中所没有的. 该指针指向结点的前一个紧邻结点.</li>
<li>level字段, 用以记录所有结点(除过头节点外)；每个结点中最多持有32个zskiplistLevel结构. 实际数量在结点创建时, 按幂次定律随机生成(不超过32). 每个zskiplistLevel中有两个字段</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>forward字段指向比自己得分高的某个结点(不一定是紧邻的), 并且, 若当前zskiplistLevel实例在level[]中的索引为X, 则其forward字段指向的结点, 其level[]字段的容量至少是X+1. 这也是上图中, 为什么forward指针总是画的水平的原因.</li>
<li>span字段代表forward字段指向的结点, 距离当前结点的距离. 紧邻的两个结点之间的距离定义为1.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="7-3-为什么不用平衡树或者哈希表"><a href="#7-3-为什么不用平衡树或者哈希表" class="headerlink" title="7.3. 为什么不用平衡树或者哈希表"></a>7.3. 为什么不用平衡树或者哈希表</h3><ul>
<li><strong>为什么不是平衡树，先看下作者的回答</strong></li>
</ul>
<p>There are a few reasons:</p>
<p>They are not very memory intensive. It’s up to you basically. Changing parameters about the probability of a node to have a given number of levels will make then less memory intensive than btrees.</p>
<p>A sorted set is often target of many ZRANGE or ZREVRANGE operations, that is, traversing the skip list as a linked list. With this operation the cache locality of skip lists is at least as good as with other kind of balanced trees.</p>
<p>They are simpler to implement, debug, and so forth. For instance thanks to the skip list simplicity I received a patch (already in Redis master) with augmented skip lists implementing ZRANK in O(log(N)). It required little changes to the code.</p>
<p>About the Append Only durability &amp; speed, I don’t think it is a good idea to optimize Redis at cost of more code and more complexity for a use case that IMHO should be rare for the Redis target (fsync() at every command). Almost no one is using this feature even with ACID SQL databases, as the performance hint is big anyway.</p>
<p>About threads: our experience shows that Redis is mostly I&#x2F;O bound. I’m using threads to serve things from Virtual Memory. The long term solution to exploit all the cores, assuming your link is so fast that you can saturate a single core, is running multiple instances of Redis (no locks, almost fully scalable linearly with number of cores), and using the “Redis Cluster” solution that I plan to develop in the future.</p>
<p>简而言之就是实现简单且达到了类似效果。</p>
<ul>
<li><strong>skiplist与平衡树、哈希表的比较</strong></li>
</ul>
<p>skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</p>
<p>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</p>
<p>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</p>
<p>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1&#x2F;(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p&#x3D;1&#x2F;4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</p>
<p>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。</p>
<p>从算法实现难度上来比较，skiplist比平衡树要简单得多。</p>
<h2 id="8-参考文章"><a href="#8-参考文章" class="headerlink" title="8. 参考文章"></a>8. 参考文章</h2><ul>
<li>Redis 6.0源码</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/neooelric/p/9621736.html">https://www.cnblogs.com/neooelric/p/9621736.html</a></li>
</ul>
<p>还参考了</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hunternet/p/11248192.html">https://www.cnblogs.com/hunternet/p/11248192.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8ac45fd01548">https://www.jianshu.com/p/8ac45fd01548</a></p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">XR</div><div class="post-copyright__author_desc">一片叶、一朵云</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2025/06/07/Redis%20%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2025/06/07/Redis%20%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/')">Redis 底层数据结构</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/kongxiaoran/image-repo/blog20241226231130275.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/kongxiaoran/image-repo/blog20241226231130275.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/kongxiaoran/image-repo/blog20241226231143327.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/kongxiaoran/image-repo/blog20241226231143327.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2025/06/07/Redis%20%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Redis 底层数据结构&amp;url=http://example.com/2025/06/07/Redis%20%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/&amp;pic=https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/20250607204045262.png" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">凌霄的博客</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"></div></div></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/20250618110852735.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/06/07/%E6%96%B0%E7%94%9F%E4%BB%A3%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AAEden+S0%20%E5%8F%AF%E4%BB%A5%E5%90%97/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/20250608162900884.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JVM新生代只有一个Eden+S0 可以吗</div></div></a></div><div class="next-post pull-right"><a href="/2025/06/07/MySQL%20%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/20250607204936123.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL 索引失效场景</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">XR</h1><div class="author-info__desc">一片叶、一朵云</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/kongxiaoran" target="_blank" title="Github"></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">Redis 底层数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BC%95%E5%85%A5"><span class="toc-number">1.1.</span> <span class="toc-text">1. 底层数据结构引入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.2.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2-sds"><span class="toc-number">1.3.</span> <span class="toc-text">2. 简单动态字符串 - sds</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-SDS-%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">2.1. SDS 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8SDS"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.2. 为什么使用SDS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%A9%BA%E9%97%B4%E9%A2%84%E5%88%86%E9%85%8D%E8%A1%A5%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%90%86%E8%A7%A3"><span class="toc-number">1.3.3.</span> <span class="toc-text">2.3. 空间预分配补进一步理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.3.4.</span> <span class="toc-text">2.4. 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8-ZipList"><span class="toc-number">1.4.</span> <span class="toc-text">3. 压缩列表 - ZipList</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-ziplist%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">3.1. ziplist结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Entry%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.2.</span> <span class="toc-text">3.2. Entry结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E4%B8%BA%E4%BB%80%E4%B9%88ZipList%E7%89%B9%E5%88%AB%E7%9C%81%E5%86%85%E5%AD%98"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.3. 为什么ZipList特别省内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-ziplist%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">1.4.4.</span> <span class="toc-text">3.4. ziplist的缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%BF%AB%E8%A1%A8-QuickList"><span class="toc-number">1.5.</span> <span class="toc-text">4. 快表 - QuickList</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-quicklist%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.1.</span> <span class="toc-text">4.1. quicklist结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-quicklist%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%9B%BE"><span class="toc-number">1.5.2.</span> <span class="toc-text">4.2. quicklist内存布局图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-quicklist%E6%9B%B4%E5%A4%9A%E9%A2%9D%E5%A4%96%E4%BF%A1%E6%81%AF"><span class="toc-number">1.5.3.</span> <span class="toc-text">4.3. quicklist更多额外信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%AD%97%E5%85%B8-%E5%93%88%E5%B8%8C%E8%A1%A8-Dict"><span class="toc-number">1.6.</span> <span class="toc-text">5. 字典&#x2F;哈希表 - Dict</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.1.</span> <span class="toc-text">5.1. 数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E4%B8%80%E4%BA%9B%E8%A6%81%E7%82%B9"><span class="toc-number">1.6.2.</span> <span class="toc-text">5.2. 一些要点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%95%B4%E6%95%B0%E9%9B%86-IntSet"><span class="toc-number">1.7.</span> <span class="toc-text">6. 整数集 - IntSet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-intset%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.1.</span> <span class="toc-text">6.1. intset结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%9B%BE"><span class="toc-number">1.7.2.</span> <span class="toc-text">6.2. 内存布局图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E7%9A%84%E5%8D%87%E7%BA%A7"><span class="toc-number">1.7.3.</span> <span class="toc-text">6.3. 整数集合的升级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E8%B7%B3%E8%A1%A8-ZSkipList"><span class="toc-number">1.8.</span> <span class="toc-text">7. 跳表 - ZSkipList</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%B3%E8%B7%83%E8%A1%A8"><span class="toc-number">1.8.1.</span> <span class="toc-text">7.1. 什么是跳跃表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-Redis%E8%B7%B3%E8%B7%83%E8%A1%A8%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.8.2.</span> <span class="toc-text">7.2. Redis跳跃表的设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E5%B9%B3%E8%A1%A1%E6%A0%91%E6%88%96%E8%80%85%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.8.3.</span> <span class="toc-text">7.3. 为什么不用平衡树或者哈希表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">1.9.</span> <span class="toc-text">8. 参考文章</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/22/Argon2%E5%AF%86%E7%A0%81%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9A%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/" title="Argon2密码哈希算法深度解析：原理、实现与实战应用">Argon2密码哈希算法深度解析：原理、实现与实战应用</a><time datetime="2025-06-22T15:00:00.000Z" title="发表于 2025-06-22 23:00:00">2025-06-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/22/synchronized%E7%9B%91%E8%A7%86%E5%99%A8%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81/" title="Java监视器有等待队列，为什么synchronized还是非公平锁？"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/20250618110852735.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java监视器有等待队列，为什么synchronized还是非公平锁？"/></a><div class="content"><a class="title" href="/2025/06/22/synchronized%E7%9B%91%E8%A7%86%E5%99%A8%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81/" title="Java监视器有等待队列，为什么synchronized还是非公平锁？">Java监视器有等待队列，为什么synchronized还是非公平锁？</a><time datetime="2025-06-22T13:00:00.000Z" title="发表于 2025-06-22 21:00:00">2025-06-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%86%E7%A0%81%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%EF%BC%9ALinux-macOS-Windows%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/" title="操作系统密码存储机制详解：Linux、macOS、Windows密码管理深度分析">操作系统密码存储机制详解：Linux、macOS、Windows密码管理深度分析</a><time datetime="2025-06-22T02:00:00.000Z" title="发表于 2025-06-22 10:00:00">2025-06-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/19/%E9%9A%90%E7%A7%81%E6%B1%82%E4%BA%A4%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%80%83/" title="关于隐私集合求交 (PSI) 的认识"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/20250607203155245.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于隐私集合求交 (PSI) 的认识"/></a><div class="content"><a class="title" href="/2025/06/19/%E9%9A%90%E7%A7%81%E6%B1%82%E4%BA%A4%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%80%83/" title="关于隐私集合求交 (PSI) 的认识">关于隐私集合求交 (PSI) 的认识</a><time datetime="2025-06-18T16:00:00.000Z" title="发表于 2025-06-19 00:00:00">2025-06-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/18/hadoop-ecosystem-explained/" title="Hadoop生态：YARN、HDFS、Hive、Spark、HBase是如何协同工作的？"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/kongxiaoran/image-repo/main/blog/20250619194740317.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hadoop生态：YARN、HDFS、Hive、Spark、HBase是如何协同工作的？"/></a><div class="content"><a class="title" href="/2025/06/18/hadoop-ecosystem-explained/" title="Hadoop生态：YARN、HDFS、Hive、Spark、HBase是如何协同工作的？">Hadoop生态：YARN、HDFS、Hive、Spark、HBase是如何协同工作的？</a><time datetime="2025-06-17T16:00:00.000Z" title="发表于 2025-06-18 00:00:00">2025-06-18</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2024 - 2025 By <a class="footer-bar-link" href="/" title="XR" target="_blank">XR</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">6</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Argon2/" style="font-size: 0.88rem;">Argon2<sup>1</sup></a><a href="/tags/HBase/" style="font-size: 0.88rem;">HBase<sup>1</sup></a><a href="/tags/HDFS/" style="font-size: 0.88rem;">HDFS<sup>2</sup></a><a href="/tags/Hadoop/" style="font-size: 0.88rem;">Hadoop<sup>1</sup></a><a href="/tags/Hive/" style="font-size: 0.88rem;">Hive<sup>1</sup></a><a href="/tags/Java/" style="font-size: 0.88rem;">Java<sup>5</sup></a><a href="/tags/Kubernetes/" style="font-size: 0.88rem;">Kubernetes<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>4</sup></a><a href="/tags/MinIO/" style="font-size: 0.88rem;">MinIO<sup>1</sup></a><a href="/tags/NAT/" style="font-size: 0.88rem;">NAT<sup>1</sup></a><a href="/tags/S3%E5%85%BC%E5%AE%B9/" style="font-size: 0.88rem;">S3兼容<sup>1</sup></a><a href="/tags/Spark/" style="font-size: 0.88rem;">Spark<sup>2</sup></a><a href="/tags/Spring/" style="font-size: 0.88rem;">Spring<sup>2</sup></a><a href="/tags/YARN/" style="font-size: 0.88rem;">YARN<sup>1</sup></a><a href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" style="font-size: 0.88rem;">云原生<sup>1</sup></a><a href="/tags/%E5%86%85%E5%AD%98%E8%AE%A1%E7%AE%97/" style="font-size: 0.88rem;">内存计算<sup>1</sup></a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%84%E7%90%86/" style="font-size: 0.88rem;">分布式处理<sup>1</sup></a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/" style="font-size: 0.88rem;">分布式存储<sup>2</sup></a><a href="/tags/%E5%93%88%E5%B8%8C/" style="font-size: 0.88rem;">哈希<sup>1</sup></a><a href="/tags/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">哈希算法<sup>1</sup></a><a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 0.88rem;">大数据<sup>1</sup></a><a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 0.88rem;">安全<sup>2</sup></a><a href="/tags/%E5%AF%86%E7%A0%81%E5%93%88%E5%B8%8C/" style="font-size: 0.88rem;">密码哈希<sup>1</sup></a><a href="/tags/%E5%AF%86%E7%A0%81%E5%AD%98%E5%82%A8/" style="font-size: 0.88rem;">密码存储<sup>1</sup></a><a href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" style="font-size: 0.88rem;">密码学<sup>1</sup></a><a href="/tags/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/" style="font-size: 0.88rem;">对象存储<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 0.88rem;">并发<sup>2</sup></a><a href="/tags/%E7%B3%BB%E7%BB%9F/" style="font-size: 0.88rem;">系统<sup>2</sup></a><a href="/tags/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/" style="font-size: 0.88rem;">系统安全<sup>2</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">网络<sup>4</sup></a><a href="/tags/%E9%98%B2%E7%81%AB%E5%A2%99/" style="font-size: 0.88rem;">防火墙<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("12/26/2024 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2024 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 XR 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.cbd.int/mermaid@10.2.4/dist/mermaid.min.js').then(runMermaid)
  }

  anzhiyu.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'cbSQtAqs68yENzUQ5wpQK826-MdYXbMMI',
      appKey: 'MR93sqmbPdh7Zm1bZzjXNvlm',
      avatar: 'mp',
      serverURLs: 'https://cbsqtaqs.api.lncldglobal.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script src="https://cdn.cbd.int/blueimp-md5@2.19.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=mp'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://cbsqtaqs.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": 'cbSQtAqs68yENzUQ5wpQK826-MdYXbMMI',
        "X-LC-Key": 'MR93sqmbPdh7Zm1bZzjXNvlm',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>